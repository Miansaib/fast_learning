// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'model.dart';

// **************************************************************************
// SqfEntityGenerator
// **************************************************************************

// ignore_for_file: non_constant_identifier_names

//  These classes was generated by SqfEntity
//  Copyright (c) 2019, All rights reserved. Use of this source code is governed by a
//  Apache license that can be found in the LICENSE file.

//  To use these SqfEntity classes do following:
//  - import model.dart into where to use
//  - start typing ex:RootGroup.select()... (add a few filters with fluent methods)...(add orderBy/orderBydesc if you want)...
//  - and then just put end of filters / or end of only select()  toSingle() / or toList()
//  - you can select one or return List<yourObject> by your filters and orders
//  - also you can batch update or batch delete by using delete/update methods instead of tosingle/tolist methods
//    Enjoy.. Huseyin Tokpunar

// BEGIN TABLES
// RootGroup TABLE
class TableRootGroup extends SqfEntityTableBase {
  TableRootGroup() {
    // declare properties of EntityTable
    tableName = 'rootGroup';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = true;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('serverId', DbType.integer),
      SqfEntityFieldBase('videoUrl', DbType.text),
      SqfEntityFieldBase('serverSync', DbType.bool),
      SqfEntityFieldBase('title', DbType.text),
      SqfEntityFieldBase('imagePath', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableRootGroup();
  }
}

// SubGroup TABLE
class TableSubGroup extends SqfEntityTableBase {
  TableSubGroup() {
    // declare properties of EntityTable
    tableName = 'subGroup';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('serverId', DbType.integer),
      SqfEntityFieldBase('orderIndex', DbType.integer),
      SqfEntityFieldBase('videoUrl', DbType.text),
      SqfEntityFieldBase('serverSync', DbType.bool),
      SqfEntityFieldBase('title', DbType.text),
      SqfEntityFieldBase('ratio', DbType.real),
      SqfEntityFieldBase('caseType', DbType.integer),
      SqfEntityFieldBase('countTime', DbType.integer),
      SqfEntityFieldBase('password', DbType.text),
      SqfEntityFieldBase('passwordConfirmed', DbType.bool),
      SqfEntityFieldBase('unitTime', DbType.integer),
      SqfEntityFieldBase('boxCount', DbType.integer),
      SqfEntityFieldBase('languageItemOne', DbType.integer),
      SqfEntityFieldBase('languageItemTwo', DbType.integer),
      SqfEntityFieldBase('languageItemThree', DbType.integer),
      SqfEntityFieldRelationshipBase(
          TableRootGroup.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'rootGroupId',
          defaultValue: 0),
      SqfEntityFieldBase('imagePath', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableSubGroup();
  }
}

// Lesson TABLE
class TableLesson extends SqfEntityTableBase {
  TableLesson() {
    // declare properties of EntityTable
    tableName = 'lesson';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('serverId', DbType.integer),
      SqfEntityFieldBase('orderIndex', DbType.integer),
      SqfEntityFieldBase('serverSync', DbType.bool),
      SqfEntityFieldBase('title', DbType.text),
      SqfEntityFieldBase('videoUrl', DbType.text),
      SqfEntityFieldBase('imagePath', DbType.text),
      SqfEntityFieldBase('storyTitle', DbType.text),
      SqfEntityFieldBase('storyDesc', DbType.text),
      SqfEntityFieldBase('storyImagePath', DbType.text),
      SqfEntityFieldBase('storyVoicePathOne', DbType.text),
      SqfEntityFieldBase('storyVoicePathTwo', DbType.text),
      SqfEntityFieldBase('descriptionTitle', DbType.text),
      SqfEntityFieldBase('descriptionDesc', DbType.text),
      SqfEntityFieldBase('descriptionImagePath', DbType.text),
      SqfEntityFieldBase('descriptionVoicePathOne', DbType.text),
      SqfEntityFieldBase('descriptionVoicePathTwo', DbType.text),
      SqfEntityFieldRelationshipBase(
          TableSubGroup.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'subGroupId',
          defaultValue: 0),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableLesson();
  }
}

// TblCard TABLE
class TableTblCard extends SqfEntityTableBase {
  TableTblCard() {
    // declare properties of EntityTable
    tableName = 'tblCard';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('serverId', DbType.integer),
      SqfEntityFieldBase('orderIndex', DbType.integer),
      SqfEntityFieldBase('serverSync', DbType.bool),
      SqfEntityFieldBase('videoUrl', DbType.text),
      SqfEntityFieldBase('spellChecker', DbType.bool, defaultValue: false),
      SqfEntityFieldBase('question', DbType.text),
      SqfEntityFieldBase('questionVoicePath', DbType.text),
      SqfEntityFieldBase('ratio', DbType.real),
      SqfEntityFieldBase('reply', DbType.text),
      SqfEntityFieldBase('replyVoicePath', DbType.text),
      SqfEntityFieldBase('description', DbType.text),
      SqfEntityFieldBase('descriptionVoicePath', DbType.text),
      SqfEntityFieldBase('imagePath', DbType.text),
      SqfEntityFieldBase('dateCreated', DbType.datetime,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('reviewStart', DbType.bool, defaultValue: false),
      SqfEntityFieldBase('examDone', DbType.bool, defaultValue: false),
      SqfEntityFieldBase('autoPlay', DbType.bool, defaultValue: true),
      SqfEntityFieldBase('autoRecord', DbType.bool, defaultValue: true),
      SqfEntityFieldBase('boxNumber', DbType.integer, defaultValue: 0),
      SqfEntityFieldBase('boxVisibleDate', DbType.datetime,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldRelationshipBase(
          TableLesson.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'lessonId',
          defaultValue: 0),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableTblCard();
  }
}

// Tablehistory TABLE
class TableTablehistory extends SqfEntityTableBase {
  TableTablehistory() {
    // declare properties of EntityTable
    tableName = 'tablehistory';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('serverId', DbType.integer),
      SqfEntityFieldBase('serverSync', DbType.bool),
      SqfEntityFieldBase('replyVoicePath', DbType.text),
      SqfEntityFieldBase('reply', DbType.text),
      SqfEntityFieldBase('dateQuestion', DbType.datetime,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('resultQuestion', DbType.integer),
      SqfEntityFieldBase('replyTimeInSecond', DbType.integer),
      SqfEntityFieldBase('goodTimeInSecond', DbType.integer),
      SqfEntityFieldBase('beforeBoxNumber', DbType.integer),
      SqfEntityFieldBase('nextBoxNumber', DbType.integer),
      SqfEntityFieldRelationshipBase(
          TableTblCard.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'tblCardId',
          defaultValue: 0),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableTablehistory();
  }
}
// END TABLES

// BEGIN SEQUENCES
// identity SEQUENCE
class SequenceIdentitySequence extends SqfEntitySequenceBase {
  SequenceIdentitySequence() {
    sequenceName = 'identity';
    maxValue =
        9007199254740991; /* optional. default is max int (9.223.372.036.854.775.807) */
    cycle = false; /* optional. default is false; */
    minValue = 0; /* optional. default is 0 */
    incrementBy = 1; /* optional. default is 1 */
    startWith = 0; /* optional. default is 0 */
    super.init();
  }
  static SequenceIdentitySequence? _instance;
  static SequenceIdentitySequence get getInstance {
    return _instance = _instance ?? SequenceIdentitySequence();
  }
}
// END SEQUENCES

// BEGIN DATABASE MODEL
class MyDbModel extends SqfEntityModelProvider {
  MyDbModel() {
    databaseName = myDbModel.databaseName;
    password = myDbModel.password;
    dbVersion = myDbModel.dbVersion;
    preSaveAction = myDbModel.preSaveAction;
    logFunction = myDbModel.logFunction;
    databaseTables = [
      TableRootGroup.getInstance,
      TableSubGroup.getInstance,
      TableLesson.getInstance,
      TableTblCard.getInstance,
      TableTablehistory.getInstance,
    ];

    sequences = [
      SequenceIdentitySequence.getInstance,
    ];

    bundledDatabasePath = myDbModel
        .bundledDatabasePath; //'assets/sample.db'; // This value is optional. When bundledDatabasePath is empty then EntityBase creats a new database when initializing the database
    databasePath = myDbModel.databasePath;
  }
  Map<String, dynamic> getControllers() {
    final controllers = <String, dynamic>{};
    controllers['rootgroup'] = RootGroupController.getController;
    controllers['subgroup'] = SubGroupController.getController;
    controllers['lesson'] = LessonController.getController;
    controllers['tblcard'] = TblCardController.getController;
    controllers['tablehistory'] = TablehistoryController.getController;

    return controllers;
  }
}
// END DATABASE MODEL

// BEGIN ENTITIES
// region RootGroup
class RootGroup extends TableBase {
  RootGroup(
      {this.id,
      this.serverId,
      this.videoUrl,
      this.serverSync,
      this.title,
      this.imagePath,
      this.isDeleted}) {
    _setDefaultValues();
    softDeleteActivated = true;
  }
  RootGroup.withFields(this.serverId, this.videoUrl, this.serverSync,
      this.title, this.imagePath, this.isDeleted) {
    _setDefaultValues();
  }
  RootGroup.withId(this.id, this.serverId, this.videoUrl, this.serverSync,
      this.title, this.imagePath, this.isDeleted) {
    _setDefaultValues();
  }
  // fromMap v2.0
  RootGroup.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['serverId'] != null) {
      serverId = int.tryParse(o['serverId'].toString());
    }
    if (o['videoUrl'] != null) {
      videoUrl = o['videoUrl'].toString();
    }
    if (o['serverSync'] != null) {
      serverSync = o['serverSync'].toString() == '1' ||
          o['serverSync'].toString() == 'true';
    }
    if (o['title'] != null) {
      title = o['title'].toString();
    }
    if (o['imagePath'] != null) {
      imagePath = o['imagePath'].toString();
    }
    isDeleted = o['isDeleted'] != null
        ? o['isDeleted'] == 1 || o['isDeleted'] == true
        : null;
  }
  // FIELDS (RootGroup)
  int? id;
  int? serverId;
  String? videoUrl;
  bool? serverSync;
  String? title;
  String? imagePath;
  bool? isDeleted;

  // end FIELDS (RootGroup)

// COLLECTIONS & VIRTUALS (RootGroup)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plSubGroups', 'plField2'..]) or so on..
  List<SubGroup>? plSubGroups;

  /// get SubGroup(s) filtered by id=rootGroupId
  SubGroupFilterBuilder? getSubGroups(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return SubGroup()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .rootGroupId
        .equals(id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (RootGroup)

  static const bool _softDeleteActivated = true;
  RootGroupManager? __mnRootGroup;

  RootGroupManager get _mnRootGroup {
    return __mnRootGroup = __mnRootGroup ?? RootGroupManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (serverId != null || !forView) {
      map['serverId'] = serverId;
    }
    if (videoUrl != null || !forView) {
      map['videoUrl'] = videoUrl;
    }
    if (serverSync != null) {
      map['serverSync'] = forQuery ? (serverSync! ? 1 : 0) : serverSync;
    } else if (serverSync != null || !forView) {
      map['serverSync'] = null;
    }
    if (title != null || !forView) {
      map['title'] = title;
    }
    if (imagePath != null || !forView) {
      map['imagePath'] = imagePath;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (serverId != null || !forView) {
      map['serverId'] = serverId;
    }
    if (videoUrl != null || !forView) {
      map['videoUrl'] = videoUrl;
    }
    if (serverSync != null) {
      map['serverSync'] = forQuery ? (serverSync! ? 1 : 0) : serverSync;
    } else if (serverSync != null || !forView) {
      map['serverSync'] = null;
    }
    if (title != null || !forView) {
      map['title'] = title;
    }
    if (imagePath != null || !forView) {
      map['imagePath'] = imagePath;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

// COLLECTIONS (RootGroup)
    if (!forQuery) {
      map['SubGroups'] = await getSubGroups()!.toMapList();
    }
// END COLLECTIONS (RootGroup)

    return map;
  }

  /// This method returns Json String [RootGroup]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [RootGroup]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [serverId, videoUrl, serverSync, title, imagePath, isDeleted];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [id, serverId, videoUrl, serverSync, title, imagePath, isDeleted];
  }

  static Future<List<RootGroup>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR RootGroup.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<RootGroup>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <RootGroup>[];
    try {
      objList = list
          .map((rootgroup) =>
              RootGroup.fromMap(rootgroup as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR RootGroup.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<RootGroup>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<RootGroup> objList = <RootGroup>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = RootGroup.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('rootGroup.plSubGroups') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSubGroups'))) {
          /*_loadedfields!.add('rootGroup.plSubGroups'); */ obj.plSubGroups =
              obj.plSubGroups ??
                  await obj.getSubGroups()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      objList.add(obj);
    }
    return objList;
  }

  /// returns RootGroup by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [RootGroup] if exist, otherwise returns null
  Future<RootGroup?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    RootGroup? obj;
    final data = await _mnRootGroup.getById([id]);
    if (data.length != 0) {
      obj = RootGroup.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('rootGroup.plSubGroups') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSubGroups'))) {
          /*_loadedfields!.add('rootGroup.plSubGroups'); */ obj.plSubGroups =
              obj.plSubGroups ??
                  await obj.getSubGroups()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (RootGroup) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnRootGroup.insert(this, ignoreBatch);
    } else {
      await _mnRootGroup.update(this);
    }

    return id;
  }

  /// Saves the (RootGroup) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnRootGroup.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnRootGroup.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs RootGroup. Returns a new Primary Key value of RootGroup

  /// <returns>Returns a new Primary Key value of RootGroup
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<RootGroup> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<RootGroup> rootgroups,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await MyDbModel().batchStart();
    for (final obj in rootgroups) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await MyDbModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < rootgroups.length; i++) {
        if (rootgroups[i].id == null) {
          rootgroups[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnRootGroup.rawInsert(
          'INSERT OR REPLACE INTO rootGroup (id, serverId, videoUrl, serverSync, title, imagePath,isDeleted)  VALUES (?,?,?,?,?,?,?)',
          [id, serverId, videoUrl, serverSync, title, imagePath, isDeleted],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'RootGroup id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'RootGroup id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'RootGroup Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<RootGroup>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<RootGroup> rootgroups,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnRootGroup.rawInsertAll(
        'INSERT OR REPLACE INTO rootGroup (id, serverId, videoUrl, serverSync, title, imagePath,isDeleted)  VALUES (?,?,?,?,?,?,?)',
        rootgroups,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes RootGroup

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete RootGroup invoked (id=$id)');
    var result = BoolResult(success: false);
    {
      result = await SubGroup()
          .select()
          .rootGroupId
          .equals(id)
          .and
          .delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    if (!_softDeleteActivated || hardDelete || isDeleted!) {
      return _mnRootGroup
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnRootGroup.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  /// Recover RootGroup

  /// <returns>BoolResult res.success=Recovered, not res.success=Can not recovered
  @override
  Future<BoolResult> recover([bool recoverChilds = true]) async {
    debugPrint('SQFENTITIY: recover RootGroup invoked (id=$id)');
    {
      return _mnRootGroup.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 0});
    }
  }

  @override
  RootGroupFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return RootGroupFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  RootGroupFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return RootGroupFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isDeleted = isDeleted ?? false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion rootgroup

// region RootGroupField
class RootGroupField extends FilterBase {
  RootGroupField(RootGroupFilterBuilder rootgroupFB) : super(rootgroupFB);

  @override
  RootGroupFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as RootGroupFilterBuilder;
  }

  @override
  RootGroupFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as RootGroupFilterBuilder;
  }

  @override
  RootGroupFilterBuilder isNull() {
    return super.isNull() as RootGroupFilterBuilder;
  }

  @override
  RootGroupFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as RootGroupFilterBuilder;
  }

  @override
  RootGroupFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as RootGroupFilterBuilder;
  }

  @override
  RootGroupFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as RootGroupFilterBuilder;
  }

  @override
  RootGroupFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as RootGroupFilterBuilder;
  }

  @override
  RootGroupFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as RootGroupFilterBuilder;
  }

  @override
  RootGroupFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as RootGroupFilterBuilder;
  }

  @override
  RootGroupFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as RootGroupFilterBuilder;
  }

  @override
  RootGroupFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as RootGroupFilterBuilder;
  }

  @override
  RootGroupFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as RootGroupFilterBuilder;
  }

  @override
  RootGroupField get not {
    return super.not as RootGroupField;
  }
}
// endregion RootGroupField

// region RootGroupFilterBuilder
class RootGroupFilterBuilder extends ConjunctionBase {
  RootGroupFilterBuilder(RootGroup obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnRootGroup = obj._mnRootGroup;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  RootGroupManager? _mnRootGroup;

  /// put the sql keyword 'AND'
  @override
  RootGroupFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  RootGroupFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  RootGroupFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  RootGroupFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  RootGroupFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  RootGroupFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  RootGroupFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  RootGroupFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  RootGroupFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  RootGroupFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  RootGroupFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  RootGroupField _setField(
      RootGroupField? field, String colName, DbType dbtype) {
    return RootGroupField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  RootGroupField? _id;
  RootGroupField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  RootGroupField? _serverId;
  RootGroupField get serverId {
    return _serverId = _setField(_serverId, 'serverId', DbType.integer);
  }

  RootGroupField? _videoUrl;
  RootGroupField get videoUrl {
    return _videoUrl = _setField(_videoUrl, 'videoUrl', DbType.text);
  }

  RootGroupField? _serverSync;
  RootGroupField get serverSync {
    return _serverSync = _setField(_serverSync, 'serverSync', DbType.bool);
  }

  RootGroupField? _title;
  RootGroupField get title {
    return _title = _setField(_title, 'title', DbType.text);
  }

  RootGroupField? _imagePath;
  RootGroupField get imagePath {
    return _imagePath = _setField(_imagePath, 'imagePath', DbType.text);
  }

  RootGroupField? _isDeleted;
  RootGroupField get isDeleted {
    return _isDeleted = _setField(_isDeleted, 'isDeleted', DbType.bool);
  }

  /// Deletes List<RootGroup> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);
    // Delete sub records where in (SubGroup) according to DeleteRule.CASCADE
    final idListSubGroupBYrootGroupId = toListPrimaryKeySQL(false);
    final resSubGroupBYrootGroupId = await SubGroup()
        .select()
        .where('rootGroupId IN (${idListSubGroupBYrootGroupId['sql']})',
            parameterValue: idListSubGroupBYrootGroupId['args'])
        .delete(hardDelete);
    if (!resSubGroupBYrootGroupId.success) {
      return resSubGroupBYrootGroupId;
    }

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnRootGroup!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnRootGroup!.delete(qparams);
    }
    return r;
  }

  /// Recover List<RootGroup> bulk by query
  @override
  Future<BoolResult> recover() async {
    buildParameters(getIsDeleted: true);
    debugPrint('SQFENTITIY: recover RootGroup bulk invoked');
    return _mnRootGroup!.updateBatch(qparams, {'isDeleted': 0});
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from rootGroup ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnRootGroup!.updateBatch(qparams, values);
  }

  /// This method always returns [RootGroup] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> RootGroup?
  @override
  Future<RootGroup?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnRootGroup!.toList(qparams);
    final data = await objFuture;
    RootGroup? obj;
    if (data.isNotEmpty) {
      obj = RootGroup.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('rootGroup.plSubGroups') && */ (preloadFields ==
                null ||
            preloadFields.contains('plSubGroups'))) {
          /*_loadedfields!.add('rootGroup.plSubGroups'); */ obj.plSubGroups =
              obj.plSubGroups ??
                  await obj.getSubGroups()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [RootGroup]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> RootGroup?
  @override
  Future<RootGroup> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        RootGroup();
  }

  /// This method returns int. [RootGroup]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? rootgroupCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final rootgroupsFuture = await _mnRootGroup!.toList(qparams);
    final int count = rootgroupsFuture[0]['CNT'] as int;
    if (rootgroupCount != null) {
      rootgroupCount(count);
    }
    return count;
  }

  /// This method returns List<RootGroup> [RootGroup]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<RootGroup>
  @override
  Future<List<RootGroup>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<RootGroup> rootgroupsData = await RootGroup.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return rootgroupsData;
  }

  /// This method returns Json String [RootGroup]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [RootGroup]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [RootGroup]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnRootGroup!.toList(qparams);
  }

  /// Returns List<DropdownMenuItem<RootGroup>>
  Future<List<DropdownMenuItem<RootGroup>>> toDropDownMenu(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<RootGroup>> o)?
          dropDownMenu]) async {
    buildParameters();
    final rootgroupsFuture = _mnRootGroup!.toList(qparams);

    final data = await rootgroupsFuture;
    final int count = data.length;
    final List<DropdownMenuItem<RootGroup>> items = []..add(DropdownMenuItem(
        value: RootGroup(),
        child: Text('-'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: RootGroup.fromMap(data[i] as Map<String, dynamic>),
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// Returns List<DropdownMenuItem<int>>
  Future<List<DropdownMenuItem<int>>> toDropDownMenuInt(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<int>> o)?
          dropDownMenu]) async {
    buildParameters();
    qparams.selectColumns = ['id', displayTextColumn];
    final rootgroupsFuture = _mnRootGroup!.toList(qparams);

    final data = await rootgroupsFuture;
    final int count = data.length;
    final List<DropdownMenuItem<int>> items = []..add(DropdownMenuItem(
        value: 0,
        child: Text('-'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: data[i]['id'] as int,
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [RootGroup]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM rootGroup WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnRootGroup!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [RootGroup]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnRootGroup!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await RootGroup.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnRootGroup!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion RootGroupFilterBuilder

// region RootGroupFields
class RootGroupFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fServerId;
  static TableField get serverId {
    return _fServerId = _fServerId ??
        SqlSyntax.setField(_fServerId, 'serverId', DbType.integer);
  }

  static TableField? _fVideoUrl;
  static TableField get videoUrl {
    return _fVideoUrl =
        _fVideoUrl ?? SqlSyntax.setField(_fVideoUrl, 'videoUrl', DbType.text);
  }

  static TableField? _fServerSync;
  static TableField get serverSync {
    return _fServerSync = _fServerSync ??
        SqlSyntax.setField(_fServerSync, 'serverSync', DbType.bool);
  }

  static TableField? _fTitle;
  static TableField get title {
    return _fTitle =
        _fTitle ?? SqlSyntax.setField(_fTitle, 'title', DbType.text);
  }

  static TableField? _fImagePath;
  static TableField get imagePath {
    return _fImagePath = _fImagePath ??
        SqlSyntax.setField(_fImagePath, 'imagePath', DbType.text);
  }

  static TableField? _fIsDeleted;
  static TableField get isDeleted {
    return _fIsDeleted = _fIsDeleted ??
        SqlSyntax.setField(_fIsDeleted, 'isDeleted', DbType.integer);
  }
}
// endregion RootGroupFields

//region RootGroupManager
class RootGroupManager extends SqfEntityProvider {
  RootGroupManager()
      : super(MyDbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'rootGroup';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion RootGroupManager
// region SubGroup
class SubGroup extends TableBase {
  SubGroup(
      {this.id,
      this.serverId,
      this.orderIndex,
      this.videoUrl,
      this.serverSync,
      this.title,
      this.ratio,
      this.caseType,
      this.countTime,
      this.password,
      this.passwordConfirmed,
      this.unitTime,
      this.boxCount,
      this.languageItemOne,
      this.languageItemTwo,
      this.languageItemThree,
      this.rootGroupId,
      this.imagePath}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  SubGroup.withFields(
      this.serverId,
      this.orderIndex,
      this.videoUrl,
      this.serverSync,
      this.title,
      this.ratio,
      this.caseType,
      this.countTime,
      this.password,
      this.passwordConfirmed,
      this.unitTime,
      this.boxCount,
      this.languageItemOne,
      this.languageItemTwo,
      this.languageItemThree,
      this.rootGroupId,
      this.imagePath) {
    _setDefaultValues();
  }
  SubGroup.withId(
      this.id,
      this.serverId,
      this.orderIndex,
      this.videoUrl,
      this.serverSync,
      this.title,
      this.ratio,
      this.caseType,
      this.countTime,
      this.password,
      this.passwordConfirmed,
      this.unitTime,
      this.boxCount,
      this.languageItemOne,
      this.languageItemTwo,
      this.languageItemThree,
      this.rootGroupId,
      this.imagePath) {
    _setDefaultValues();
  }
  // fromMap v2.0
  SubGroup.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['serverId'] != null) {
      serverId = int.tryParse(o['serverId'].toString());
    }
    if (o['orderIndex'] != null) {
      orderIndex = int.tryParse(o['orderIndex'].toString());
    }
    if (o['videoUrl'] != null) {
      videoUrl = o['videoUrl'].toString();
    }
    if (o['serverSync'] != null) {
      serverSync = o['serverSync'].toString() == '1' ||
          o['serverSync'].toString() == 'true';
    }
    if (o['title'] != null) {
      title = o['title'].toString();
    }
    if (o['ratio'] != null) {
      ratio = double.tryParse(o['ratio'].toString());
    }
    if (o['caseType'] != null) {
      caseType = int.tryParse(o['caseType'].toString());
    }
    if (o['countTime'] != null) {
      countTime = int.tryParse(o['countTime'].toString());
    }
    if (o['password'] != null) {
      password = o['password'].toString();
    }
    if (o['passwordConfirmed'] != null) {
      passwordConfirmed = o['passwordConfirmed'].toString() == '1' ||
          o['passwordConfirmed'].toString() == 'true';
    }
    if (o['unitTime'] != null) {
      unitTime = int.tryParse(o['unitTime'].toString());
    }
    if (o['boxCount'] != null) {
      boxCount = int.tryParse(o['boxCount'].toString());
    }
    if (o['languageItemOne'] != null) {
      languageItemOne = int.tryParse(o['languageItemOne'].toString());
    }
    if (o['languageItemTwo'] != null) {
      languageItemTwo = int.tryParse(o['languageItemTwo'].toString());
    }
    if (o['languageItemThree'] != null) {
      languageItemThree = int.tryParse(o['languageItemThree'].toString());
    }
    rootGroupId = int.tryParse(o['rootGroupId'].toString());

    if (o['imagePath'] != null) {
      imagePath = o['imagePath'].toString();
    }

    // RELATIONSHIPS FromMAP
    plRootGroup = o['rootGroup'] != null
        ? RootGroup.fromMap(o['rootGroup'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP
  }
  // FIELDS (SubGroup)
  int? id;
  int? serverId;
  int? orderIndex;
  String? videoUrl;
  bool? serverSync;
  String? title;
  double? ratio;
  int? caseType;
  int? countTime;
  String? password;
  bool? passwordConfirmed;
  int? unitTime;
  int? boxCount;
  int? languageItemOne;
  int? languageItemTwo;
  int? languageItemThree;
  int? rootGroupId;
  String? imagePath;

  // end FIELDS (SubGroup)

// RELATIONSHIPS (SubGroup)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plRootGroup', 'plField2'..]) or so on..
  RootGroup? plRootGroup;

  /// get RootGroup By RootGroupId
  Future<RootGroup?> getRootGroup(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await RootGroup().getById(rootGroupId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (SubGroup)

// COLLECTIONS & VIRTUALS (SubGroup)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plLessons', 'plField2'..]) or so on..
  List<Lesson>? plLessons;

  /// get Lesson(s) filtered by id=subGroupId
  LessonFilterBuilder? getLessons(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return Lesson()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .subGroupId
        .equals(id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (SubGroup)

  static const bool _softDeleteActivated = false;
  SubGroupManager? __mnSubGroup;

  SubGroupManager get _mnSubGroup {
    return __mnSubGroup = __mnSubGroup ?? SubGroupManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (serverId != null || !forView) {
      map['serverId'] = serverId;
    }
    if (orderIndex != null || !forView) {
      map['orderIndex'] = orderIndex;
    }
    if (videoUrl != null || !forView) {
      map['videoUrl'] = videoUrl;
    }
    if (serverSync != null) {
      map['serverSync'] = forQuery ? (serverSync! ? 1 : 0) : serverSync;
    } else if (serverSync != null || !forView) {
      map['serverSync'] = null;
    }
    if (title != null || !forView) {
      map['title'] = title;
    }
    if (ratio != null || !forView) {
      map['ratio'] = ratio;
    }
    if (caseType != null || !forView) {
      map['caseType'] = caseType;
    }
    if (countTime != null || !forView) {
      map['countTime'] = countTime;
    }
    if (password != null || !forView) {
      map['password'] = password;
    }
    if (passwordConfirmed != null) {
      map['passwordConfirmed'] =
          forQuery ? (passwordConfirmed! ? 1 : 0) : passwordConfirmed;
    } else if (passwordConfirmed != null || !forView) {
      map['passwordConfirmed'] = null;
    }
    if (unitTime != null || !forView) {
      map['unitTime'] = unitTime;
    }
    if (boxCount != null || !forView) {
      map['boxCount'] = boxCount;
    }
    if (languageItemOne != null || !forView) {
      map['languageItemOne'] = languageItemOne;
    }
    if (languageItemTwo != null || !forView) {
      map['languageItemTwo'] = languageItemTwo;
    }
    if (languageItemThree != null || !forView) {
      map['languageItemThree'] = languageItemThree;
    }
    if (rootGroupId != null) {
      map['rootGroupId'] = forView
          ? plRootGroup == null
              ? rootGroupId
              : plRootGroup!.videoUrl
          : rootGroupId;
    } else if (rootGroupId != null || !forView) {
      map['rootGroupId'] = null;
    }
    if (imagePath != null || !forView) {
      map['imagePath'] = imagePath;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (serverId != null || !forView) {
      map['serverId'] = serverId;
    }
    if (orderIndex != null || !forView) {
      map['orderIndex'] = orderIndex;
    }
    if (videoUrl != null || !forView) {
      map['videoUrl'] = videoUrl;
    }
    if (serverSync != null) {
      map['serverSync'] = forQuery ? (serverSync! ? 1 : 0) : serverSync;
    } else if (serverSync != null || !forView) {
      map['serverSync'] = null;
    }
    if (title != null || !forView) {
      map['title'] = title;
    }
    if (ratio != null || !forView) {
      map['ratio'] = ratio;
    }
    if (caseType != null || !forView) {
      map['caseType'] = caseType;
    }
    if (countTime != null || !forView) {
      map['countTime'] = countTime;
    }
    if (password != null || !forView) {
      map['password'] = password;
    }
    if (passwordConfirmed != null) {
      map['passwordConfirmed'] =
          forQuery ? (passwordConfirmed! ? 1 : 0) : passwordConfirmed;
    } else if (passwordConfirmed != null || !forView) {
      map['passwordConfirmed'] = null;
    }
    if (unitTime != null || !forView) {
      map['unitTime'] = unitTime;
    }
    if (boxCount != null || !forView) {
      map['boxCount'] = boxCount;
    }
    if (languageItemOne != null || !forView) {
      map['languageItemOne'] = languageItemOne;
    }
    if (languageItemTwo != null || !forView) {
      map['languageItemTwo'] = languageItemTwo;
    }
    if (languageItemThree != null || !forView) {
      map['languageItemThree'] = languageItemThree;
    }
    if (rootGroupId != null) {
      map['rootGroupId'] = forView
          ? plRootGroup == null
              ? rootGroupId
              : plRootGroup!.videoUrl
          : rootGroupId;
    } else if (rootGroupId != null || !forView) {
      map['rootGroupId'] = null;
    }
    if (imagePath != null || !forView) {
      map['imagePath'] = imagePath;
    }

// COLLECTIONS (SubGroup)
    if (!forQuery) {
      map['Lessons'] = await getLessons()!.toMapList();
    }
// END COLLECTIONS (SubGroup)

    return map;
  }

  /// This method returns Json String [SubGroup]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [SubGroup]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      serverId,
      orderIndex,
      videoUrl,
      serverSync,
      title,
      ratio,
      caseType,
      countTime,
      password,
      passwordConfirmed,
      unitTime,
      boxCount,
      languageItemOne,
      languageItemTwo,
      languageItemThree,
      rootGroupId,
      imagePath
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      id,
      serverId,
      orderIndex,
      videoUrl,
      serverSync,
      title,
      ratio,
      caseType,
      countTime,
      password,
      passwordConfirmed,
      unitTime,
      boxCount,
      languageItemOne,
      languageItemTwo,
      languageItemThree,
      rootGroupId,
      imagePath
    ];
  }

  static Future<List<SubGroup>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR SubGroup.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<SubGroup>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <SubGroup>[];
    try {
      objList = list
          .map((subgroup) => SubGroup.fromMap(subgroup as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR SubGroup.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<SubGroup>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<SubGroup> objList = <SubGroup>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = SubGroup.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('subGroup.plLessons') && */ (preloadFields ==
                null ||
            preloadFields.contains('plLessons'))) {
          /*_loadedfields!.add('subGroup.plLessons'); */ obj.plLessons =
              obj.plLessons ??
                  await obj.getLessons()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plRootGroup'))) {
          obj.plRootGroup = obj.plRootGroup ??
              await obj.getRootGroup(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns SubGroup by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [SubGroup] if exist, otherwise returns null
  Future<SubGroup?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    SubGroup? obj;
    final data = await _mnSubGroup.getById([id]);
    if (data.length != 0) {
      obj = SubGroup.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('subGroup.plLessons') && */ (preloadFields ==
                null ||
            preloadFields.contains('plLessons'))) {
          /*_loadedfields!.add('subGroup.plLessons'); */ obj.plLessons =
              obj.plLessons ??
                  await obj.getLessons()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plRootGroup'))) {
          obj.plRootGroup = obj.plRootGroup ??
              await obj.getRootGroup(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (SubGroup) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnSubGroup.insert(this, ignoreBatch);
    } else {
      await _mnSubGroup.update(this);
    }

    return id;
  }

  /// Saves the (SubGroup) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnSubGroup.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnSubGroup.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs SubGroup. Returns a new Primary Key value of SubGroup

  /// <returns>Returns a new Primary Key value of SubGroup
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<SubGroup> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<SubGroup> subgroups,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await MyDbModel().batchStart();
    for (final obj in subgroups) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await MyDbModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < subgroups.length; i++) {
        if (subgroups[i].id == null) {
          subgroups[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnSubGroup.rawInsert(
          'INSERT OR REPLACE INTO subGroup (id, serverId, orderIndex, videoUrl, serverSync, title, ratio, caseType, countTime, password, passwordConfirmed, unitTime, boxCount, languageItemOne, languageItemTwo, languageItemThree, rootGroupId, imagePath)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            id,
            serverId,
            orderIndex,
            videoUrl,
            serverSync,
            title,
            ratio,
            caseType,
            countTime,
            password,
            passwordConfirmed,
            unitTime,
            boxCount,
            languageItemOne,
            languageItemTwo,
            languageItemThree,
            rootGroupId,
            imagePath
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'SubGroup id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'SubGroup id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'SubGroup Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<SubGroup>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<SubGroup> subgroups,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnSubGroup.rawInsertAll(
        'INSERT OR REPLACE INTO subGroup (id, serverId, orderIndex, videoUrl, serverSync, title, ratio, caseType, countTime, password, passwordConfirmed, unitTime, boxCount, languageItemOne, languageItemTwo, languageItemThree, rootGroupId, imagePath)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
        subgroups,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes SubGroup

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete SubGroup invoked (id=$id)');
    var result = BoolResult(success: false);
    {
      result =
          await Lesson().select().subGroupId.equals(id).and.delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnSubGroup
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnSubGroup.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [SubGroup] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  SubGroupFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return SubGroupFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  SubGroupFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return SubGroupFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    rootGroupId = rootGroupId ?? 0;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion subgroup

// region SubGroupField
class SubGroupField extends FilterBase {
  SubGroupField(SubGroupFilterBuilder subgroupFB) : super(subgroupFB);

  @override
  SubGroupFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as SubGroupFilterBuilder;
  }

  @override
  SubGroupFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as SubGroupFilterBuilder;
  }

  @override
  SubGroupFilterBuilder isNull() {
    return super.isNull() as SubGroupFilterBuilder;
  }

  @override
  SubGroupFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as SubGroupFilterBuilder;
  }

  @override
  SubGroupFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as SubGroupFilterBuilder;
  }

  @override
  SubGroupFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as SubGroupFilterBuilder;
  }

  @override
  SubGroupFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as SubGroupFilterBuilder;
  }

  @override
  SubGroupFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as SubGroupFilterBuilder;
  }

  @override
  SubGroupFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as SubGroupFilterBuilder;
  }

  @override
  SubGroupFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as SubGroupFilterBuilder;
  }

  @override
  SubGroupFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as SubGroupFilterBuilder;
  }

  @override
  SubGroupFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as SubGroupFilterBuilder;
  }

  @override
  SubGroupField get not {
    return super.not as SubGroupField;
  }
}
// endregion SubGroupField

// region SubGroupFilterBuilder
class SubGroupFilterBuilder extends ConjunctionBase {
  SubGroupFilterBuilder(SubGroup obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnSubGroup = obj._mnSubGroup;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  SubGroupManager? _mnSubGroup;

  /// put the sql keyword 'AND'
  @override
  SubGroupFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  SubGroupFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  SubGroupFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  SubGroupFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  SubGroupFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  SubGroupFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  SubGroupFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  SubGroupFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  SubGroupFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  SubGroupFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  SubGroupFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  SubGroupField _setField(SubGroupField? field, String colName, DbType dbtype) {
    return SubGroupField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  SubGroupField? _id;
  SubGroupField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  SubGroupField? _serverId;
  SubGroupField get serverId {
    return _serverId = _setField(_serverId, 'serverId', DbType.integer);
  }

  SubGroupField? _orderIndex;
  SubGroupField get orderIndex {
    return _orderIndex = _setField(_orderIndex, 'orderIndex', DbType.integer);
  }

  SubGroupField? _videoUrl;
  SubGroupField get videoUrl {
    return _videoUrl = _setField(_videoUrl, 'videoUrl', DbType.text);
  }

  SubGroupField? _serverSync;
  SubGroupField get serverSync {
    return _serverSync = _setField(_serverSync, 'serverSync', DbType.bool);
  }

  SubGroupField? _title;
  SubGroupField get title {
    return _title = _setField(_title, 'title', DbType.text);
  }

  SubGroupField? _ratio;
  SubGroupField get ratio {
    return _ratio = _setField(_ratio, 'ratio', DbType.real);
  }

  SubGroupField? _caseType;
  SubGroupField get caseType {
    return _caseType = _setField(_caseType, 'caseType', DbType.integer);
  }

  SubGroupField? _countTime;
  SubGroupField get countTime {
    return _countTime = _setField(_countTime, 'countTime', DbType.integer);
  }

  SubGroupField? _password;
  SubGroupField get password {
    return _password = _setField(_password, 'password', DbType.text);
  }

  SubGroupField? _passwordConfirmed;
  SubGroupField get passwordConfirmed {
    return _passwordConfirmed =
        _setField(_passwordConfirmed, 'passwordConfirmed', DbType.bool);
  }

  SubGroupField? _unitTime;
  SubGroupField get unitTime {
    return _unitTime = _setField(_unitTime, 'unitTime', DbType.integer);
  }

  SubGroupField? _boxCount;
  SubGroupField get boxCount {
    return _boxCount = _setField(_boxCount, 'boxCount', DbType.integer);
  }

  SubGroupField? _languageItemOne;
  SubGroupField get languageItemOne {
    return _languageItemOne =
        _setField(_languageItemOne, 'languageItemOne', DbType.integer);
  }

  SubGroupField? _languageItemTwo;
  SubGroupField get languageItemTwo {
    return _languageItemTwo =
        _setField(_languageItemTwo, 'languageItemTwo', DbType.integer);
  }

  SubGroupField? _languageItemThree;
  SubGroupField get languageItemThree {
    return _languageItemThree =
        _setField(_languageItemThree, 'languageItemThree', DbType.integer);
  }

  SubGroupField? _rootGroupId;
  SubGroupField get rootGroupId {
    return _rootGroupId =
        _setField(_rootGroupId, 'rootGroupId', DbType.integer);
  }

  SubGroupField? _imagePath;
  SubGroupField get imagePath {
    return _imagePath = _setField(_imagePath, 'imagePath', DbType.text);
  }

  /// Deletes List<SubGroup> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);
    // Delete sub records where in (Lesson) according to DeleteRule.CASCADE
    final idListLessonBYsubGroupId = toListPrimaryKeySQL(false);
    final resLessonBYsubGroupId = await Lesson()
        .select()
        .where('subGroupId IN (${idListLessonBYsubGroupId['sql']})',
            parameterValue: idListLessonBYsubGroupId['args'])
        .delete(hardDelete);
    if (!resLessonBYsubGroupId.success) {
      return resLessonBYsubGroupId;
    }

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnSubGroup!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnSubGroup!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from subGroup ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnSubGroup!.updateBatch(qparams, values);
  }

  /// This method always returns [SubGroup] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> SubGroup?
  @override
  Future<SubGroup?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnSubGroup!.toList(qparams);
    final data = await objFuture;
    SubGroup? obj;
    if (data.isNotEmpty) {
      obj = SubGroup.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('subGroup.plLessons') && */ (preloadFields ==
                null ||
            preloadFields.contains('plLessons'))) {
          /*_loadedfields!.add('subGroup.plLessons'); */ obj.plLessons =
              obj.plLessons ??
                  await obj.getLessons()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plRootGroup'))) {
          obj.plRootGroup = obj.plRootGroup ??
              await obj.getRootGroup(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [SubGroup]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> SubGroup?
  @override
  Future<SubGroup> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        SubGroup();
  }

  /// This method returns int. [SubGroup]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? subgroupCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final subgroupsFuture = await _mnSubGroup!.toList(qparams);
    final int count = subgroupsFuture[0]['CNT'] as int;
    if (subgroupCount != null) {
      subgroupCount(count);
    }
    return count;
  }

  /// This method returns List<SubGroup> [SubGroup]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<SubGroup>
  @override
  Future<List<SubGroup>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<SubGroup> subgroupsData = await SubGroup.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return subgroupsData;
  }

  /// This method returns Json String [SubGroup]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [SubGroup]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [SubGroup]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnSubGroup!.toList(qparams);
  }

  /// Returns List<DropdownMenuItem<SubGroup>>
  Future<List<DropdownMenuItem<SubGroup>>> toDropDownMenu(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<SubGroup>> o)?
          dropDownMenu]) async {
    buildParameters();
    final subgroupsFuture = _mnSubGroup!.toList(qparams);

    final data = await subgroupsFuture;
    final int count = data.length;
    final List<DropdownMenuItem<SubGroup>> items = []..add(DropdownMenuItem(
        value: SubGroup(),
        child: Text('-'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: SubGroup.fromMap(data[i] as Map<String, dynamic>),
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// Returns List<DropdownMenuItem<int>>
  Future<List<DropdownMenuItem<int>>> toDropDownMenuInt(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<int>> o)?
          dropDownMenu]) async {
    buildParameters();
    qparams.selectColumns = ['id', displayTextColumn];
    final subgroupsFuture = _mnSubGroup!.toList(qparams);

    final data = await subgroupsFuture;
    final int count = data.length;
    final List<DropdownMenuItem<int>> items = []..add(DropdownMenuItem(
        value: 0,
        child: Text('-'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: data[i]['id'] as int,
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [SubGroup]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM subGroup WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnSubGroup!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [SubGroup]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnSubGroup!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await SubGroup.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnSubGroup!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion SubGroupFilterBuilder

// region SubGroupFields
class SubGroupFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fServerId;
  static TableField get serverId {
    return _fServerId = _fServerId ??
        SqlSyntax.setField(_fServerId, 'serverId', DbType.integer);
  }

  static TableField? _fOrderIndex;
  static TableField get orderIndex {
    return _fOrderIndex = _fOrderIndex ??
        SqlSyntax.setField(_fOrderIndex, 'orderIndex', DbType.integer);
  }

  static TableField? _fVideoUrl;
  static TableField get videoUrl {
    return _fVideoUrl =
        _fVideoUrl ?? SqlSyntax.setField(_fVideoUrl, 'videoUrl', DbType.text);
  }

  static TableField? _fServerSync;
  static TableField get serverSync {
    return _fServerSync = _fServerSync ??
        SqlSyntax.setField(_fServerSync, 'serverSync', DbType.bool);
  }

  static TableField? _fTitle;
  static TableField get title {
    return _fTitle =
        _fTitle ?? SqlSyntax.setField(_fTitle, 'title', DbType.text);
  }

  static TableField? _fRatio;
  static TableField get ratio {
    return _fRatio =
        _fRatio ?? SqlSyntax.setField(_fRatio, 'ratio', DbType.real);
  }

  static TableField? _fCaseType;
  static TableField get caseType {
    return _fCaseType = _fCaseType ??
        SqlSyntax.setField(_fCaseType, 'caseType', DbType.integer);
  }

  static TableField? _fCountTime;
  static TableField get countTime {
    return _fCountTime = _fCountTime ??
        SqlSyntax.setField(_fCountTime, 'countTime', DbType.integer);
  }

  static TableField? _fPassword;
  static TableField get password {
    return _fPassword =
        _fPassword ?? SqlSyntax.setField(_fPassword, 'password', DbType.text);
  }

  static TableField? _fPasswordConfirmed;
  static TableField get passwordConfirmed {
    return _fPasswordConfirmed = _fPasswordConfirmed ??
        SqlSyntax.setField(
            _fPasswordConfirmed, 'passwordConfirmed', DbType.bool);
  }

  static TableField? _fUnitTime;
  static TableField get unitTime {
    return _fUnitTime = _fUnitTime ??
        SqlSyntax.setField(_fUnitTime, 'unitTime', DbType.integer);
  }

  static TableField? _fBoxCount;
  static TableField get boxCount {
    return _fBoxCount = _fBoxCount ??
        SqlSyntax.setField(_fBoxCount, 'boxCount', DbType.integer);
  }

  static TableField? _fLanguageItemOne;
  static TableField get languageItemOne {
    return _fLanguageItemOne = _fLanguageItemOne ??
        SqlSyntax.setField(
            _fLanguageItemOne, 'languageItemOne', DbType.integer);
  }

  static TableField? _fLanguageItemTwo;
  static TableField get languageItemTwo {
    return _fLanguageItemTwo = _fLanguageItemTwo ??
        SqlSyntax.setField(
            _fLanguageItemTwo, 'languageItemTwo', DbType.integer);
  }

  static TableField? _fLanguageItemThree;
  static TableField get languageItemThree {
    return _fLanguageItemThree = _fLanguageItemThree ??
        SqlSyntax.setField(
            _fLanguageItemThree, 'languageItemThree', DbType.integer);
  }

  static TableField? _fRootGroupId;
  static TableField get rootGroupId {
    return _fRootGroupId = _fRootGroupId ??
        SqlSyntax.setField(_fRootGroupId, 'rootGroupId', DbType.integer);
  }

  static TableField? _fImagePath;
  static TableField get imagePath {
    return _fImagePath = _fImagePath ??
        SqlSyntax.setField(_fImagePath, 'imagePath', DbType.text);
  }
}
// endregion SubGroupFields

//region SubGroupManager
class SubGroupManager extends SqfEntityProvider {
  SubGroupManager()
      : super(MyDbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'subGroup';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion SubGroupManager
// region Lesson
class Lesson extends TableBase {
  Lesson(
      {this.id,
      this.serverId,
      this.orderIndex,
      this.serverSync,
      this.title,
      this.videoUrl,
      this.imagePath,
      this.storyTitle,
      this.storyDesc,
      this.storyImagePath,
      this.storyVoicePathOne,
      this.storyVoicePathTwo,
      this.descriptionTitle,
      this.descriptionDesc,
      this.descriptionImagePath,
      this.descriptionVoicePathOne,
      this.descriptionVoicePathTwo,
      this.subGroupId}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  Lesson.withFields(
      this.serverId,
      this.orderIndex,
      this.serverSync,
      this.title,
      this.videoUrl,
      this.imagePath,
      this.storyTitle,
      this.storyDesc,
      this.storyImagePath,
      this.storyVoicePathOne,
      this.storyVoicePathTwo,
      this.descriptionTitle,
      this.descriptionDesc,
      this.descriptionImagePath,
      this.descriptionVoicePathOne,
      this.descriptionVoicePathTwo,
      this.subGroupId) {
    _setDefaultValues();
  }
  Lesson.withId(
      this.id,
      this.serverId,
      this.orderIndex,
      this.serverSync,
      this.title,
      this.videoUrl,
      this.imagePath,
      this.storyTitle,
      this.storyDesc,
      this.storyImagePath,
      this.storyVoicePathOne,
      this.storyVoicePathTwo,
      this.descriptionTitle,
      this.descriptionDesc,
      this.descriptionImagePath,
      this.descriptionVoicePathOne,
      this.descriptionVoicePathTwo,
      this.subGroupId) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Lesson.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['serverId'] != null) {
      serverId = int.tryParse(o['serverId'].toString());
    }
    if (o['orderIndex'] != null) {
      orderIndex = int.tryParse(o['orderIndex'].toString());
    }
    if (o['serverSync'] != null) {
      serverSync = o['serverSync'].toString() == '1' ||
          o['serverSync'].toString() == 'true';
    }
    if (o['title'] != null) {
      title = o['title'].toString();
    }
    if (o['videoUrl'] != null) {
      videoUrl = o['videoUrl'].toString();
    }
    if (o['imagePath'] != null) {
      imagePath = o['imagePath'].toString();
    }
    if (o['storyTitle'] != null) {
      storyTitle = o['storyTitle'].toString();
    }
    if (o['storyDesc'] != null) {
      storyDesc = o['storyDesc'].toString();
    }
    if (o['storyImagePath'] != null) {
      storyImagePath = o['storyImagePath'].toString();
    }
    if (o['storyVoicePathOne'] != null) {
      storyVoicePathOne = o['storyVoicePathOne'].toString();
    }
    if (o['storyVoicePathTwo'] != null) {
      storyVoicePathTwo = o['storyVoicePathTwo'].toString();
    }
    if (o['descriptionTitle'] != null) {
      descriptionTitle = o['descriptionTitle'].toString();
    }
    if (o['descriptionDesc'] != null) {
      descriptionDesc = o['descriptionDesc'].toString();
    }
    if (o['descriptionImagePath'] != null) {
      descriptionImagePath = o['descriptionImagePath'].toString();
    }
    if (o['descriptionVoicePathOne'] != null) {
      descriptionVoicePathOne = o['descriptionVoicePathOne'].toString();
    }
    if (o['descriptionVoicePathTwo'] != null) {
      descriptionVoicePathTwo = o['descriptionVoicePathTwo'].toString();
    }
    subGroupId = int.tryParse(o['subGroupId'].toString());

    // RELATIONSHIPS FromMAP
    plSubGroup = o['subGroup'] != null
        ? SubGroup.fromMap(o['subGroup'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP
  }
  // FIELDS (Lesson)
  int? id;
  int? serverId;
  int? orderIndex;
  bool? serverSync;
  String? title;
  String? videoUrl;
  String? imagePath;
  String? storyTitle;
  String? storyDesc;
  String? storyImagePath;
  String? storyVoicePathOne;
  String? storyVoicePathTwo;
  String? descriptionTitle;
  String? descriptionDesc;
  String? descriptionImagePath;
  String? descriptionVoicePathOne;
  String? descriptionVoicePathTwo;
  int? subGroupId;

  // end FIELDS (Lesson)

// RELATIONSHIPS (Lesson)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plSubGroup', 'plField2'..]) or so on..
  SubGroup? plSubGroup;

  /// get SubGroup By SubGroupId
  Future<SubGroup?> getSubGroup(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await SubGroup().getById(subGroupId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (Lesson)

// COLLECTIONS & VIRTUALS (Lesson)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plTblCards', 'plField2'..]) or so on..
  List<TblCard>? plTblCards;

  /// get TblCard(s) filtered by id=lessonId
  TblCardFilterBuilder? getTblCards(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return TblCard()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .lessonId
        .equals(id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (Lesson)

  static const bool _softDeleteActivated = false;
  LessonManager? __mnLesson;

  LessonManager get _mnLesson {
    return __mnLesson = __mnLesson ?? LessonManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (serverId != null || !forView) {
      map['serverId'] = serverId;
    }
    if (orderIndex != null || !forView) {
      map['orderIndex'] = orderIndex;
    }
    if (serverSync != null) {
      map['serverSync'] = forQuery ? (serverSync! ? 1 : 0) : serverSync;
    } else if (serverSync != null || !forView) {
      map['serverSync'] = null;
    }
    if (title != null || !forView) {
      map['title'] = title;
    }
    if (videoUrl != null || !forView) {
      map['videoUrl'] = videoUrl;
    }
    if (imagePath != null || !forView) {
      map['imagePath'] = imagePath;
    }
    if (storyTitle != null || !forView) {
      map['storyTitle'] = storyTitle;
    }
    if (storyDesc != null || !forView) {
      map['storyDesc'] = storyDesc;
    }
    if (storyImagePath != null || !forView) {
      map['storyImagePath'] = storyImagePath;
    }
    if (storyVoicePathOne != null || !forView) {
      map['storyVoicePathOne'] = storyVoicePathOne;
    }
    if (storyVoicePathTwo != null || !forView) {
      map['storyVoicePathTwo'] = storyVoicePathTwo;
    }
    if (descriptionTitle != null || !forView) {
      map['descriptionTitle'] = descriptionTitle;
    }
    if (descriptionDesc != null || !forView) {
      map['descriptionDesc'] = descriptionDesc;
    }
    if (descriptionImagePath != null || !forView) {
      map['descriptionImagePath'] = descriptionImagePath;
    }
    if (descriptionVoicePathOne != null || !forView) {
      map['descriptionVoicePathOne'] = descriptionVoicePathOne;
    }
    if (descriptionVoicePathTwo != null || !forView) {
      map['descriptionVoicePathTwo'] = descriptionVoicePathTwo;
    }
    if (subGroupId != null) {
      map['subGroupId'] = forView
          ? plSubGroup == null
              ? subGroupId
              : plSubGroup!.videoUrl
          : subGroupId;
    } else if (subGroupId != null || !forView) {
      map['subGroupId'] = null;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (serverId != null || !forView) {
      map['serverId'] = serverId;
    }
    if (orderIndex != null || !forView) {
      map['orderIndex'] = orderIndex;
    }
    if (serverSync != null) {
      map['serverSync'] = forQuery ? (serverSync! ? 1 : 0) : serverSync;
    } else if (serverSync != null || !forView) {
      map['serverSync'] = null;
    }
    if (title != null || !forView) {
      map['title'] = title;
    }
    if (videoUrl != null || !forView) {
      map['videoUrl'] = videoUrl;
    }
    if (imagePath != null || !forView) {
      map['imagePath'] = imagePath;
    }
    if (storyTitle != null || !forView) {
      map['storyTitle'] = storyTitle;
    }
    if (storyDesc != null || !forView) {
      map['storyDesc'] = storyDesc;
    }
    if (storyImagePath != null || !forView) {
      map['storyImagePath'] = storyImagePath;
    }
    if (storyVoicePathOne != null || !forView) {
      map['storyVoicePathOne'] = storyVoicePathOne;
    }
    if (storyVoicePathTwo != null || !forView) {
      map['storyVoicePathTwo'] = storyVoicePathTwo;
    }
    if (descriptionTitle != null || !forView) {
      map['descriptionTitle'] = descriptionTitle;
    }
    if (descriptionDesc != null || !forView) {
      map['descriptionDesc'] = descriptionDesc;
    }
    if (descriptionImagePath != null || !forView) {
      map['descriptionImagePath'] = descriptionImagePath;
    }
    if (descriptionVoicePathOne != null || !forView) {
      map['descriptionVoicePathOne'] = descriptionVoicePathOne;
    }
    if (descriptionVoicePathTwo != null || !forView) {
      map['descriptionVoicePathTwo'] = descriptionVoicePathTwo;
    }
    if (subGroupId != null) {
      map['subGroupId'] = forView
          ? plSubGroup == null
              ? subGroupId
              : plSubGroup!.videoUrl
          : subGroupId;
    } else if (subGroupId != null || !forView) {
      map['subGroupId'] = null;
    }

// COLLECTIONS (Lesson)
    if (!forQuery) {
      map['TblCards'] = await getTblCards()!.toMapList();
    }
// END COLLECTIONS (Lesson)

    return map;
  }

  /// This method returns Json String [Lesson]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Lesson]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      serverId,
      orderIndex,
      serverSync,
      title,
      videoUrl,
      imagePath,
      storyTitle,
      storyDesc,
      storyImagePath,
      storyVoicePathOne,
      storyVoicePathTwo,
      descriptionTitle,
      descriptionDesc,
      descriptionImagePath,
      descriptionVoicePathOne,
      descriptionVoicePathTwo,
      subGroupId
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      id,
      serverId,
      orderIndex,
      serverSync,
      title,
      videoUrl,
      imagePath,
      storyTitle,
      storyDesc,
      storyImagePath,
      storyVoicePathOne,
      storyVoicePathTwo,
      descriptionTitle,
      descriptionDesc,
      descriptionImagePath,
      descriptionVoicePathOne,
      descriptionVoicePathTwo,
      subGroupId
    ];
  }

  static Future<List<Lesson>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Lesson.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Lesson>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Lesson>[];
    try {
      objList = list
          .map((lesson) => Lesson.fromMap(lesson as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Lesson.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Lesson>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Lesson> objList = <Lesson>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Lesson.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('lesson.plTblCards') && */ (preloadFields ==
                null ||
            preloadFields.contains('plTblCards'))) {
          /*_loadedfields!.add('lesson.plTblCards'); */ obj.plTblCards =
              obj.plTblCards ??
                  await obj.getTblCards()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plSubGroup'))) {
          obj.plSubGroup =
              obj.plSubGroup ?? await obj.getSubGroup(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Lesson by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Lesson] if exist, otherwise returns null
  Future<Lesson?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    Lesson? obj;
    final data = await _mnLesson.getById([id]);
    if (data.length != 0) {
      obj = Lesson.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('lesson.plTblCards') && */ (preloadFields ==
                null ||
            preloadFields.contains('plTblCards'))) {
          /*_loadedfields!.add('lesson.plTblCards'); */ obj.plTblCards =
              obj.plTblCards ??
                  await obj.getTblCards()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plSubGroup'))) {
          obj.plSubGroup =
              obj.plSubGroup ?? await obj.getSubGroup(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Lesson) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnLesson.insert(this, ignoreBatch);
    } else {
      await _mnLesson.update(this);
    }

    return id;
  }

  /// Saves the (Lesson) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnLesson.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnLesson.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs Lesson. Returns a new Primary Key value of Lesson

  /// <returns>Returns a new Primary Key value of Lesson
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<Lesson> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Lesson> lessons,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await MyDbModel().batchStart();
    for (final obj in lessons) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await MyDbModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < lessons.length; i++) {
        if (lessons[i].id == null) {
          lessons[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnLesson.rawInsert(
          'INSERT OR REPLACE INTO lesson (id, serverId, orderIndex, serverSync, title, videoUrl, imagePath, storyTitle, storyDesc, storyImagePath, storyVoicePathOne, storyVoicePathTwo, descriptionTitle, descriptionDesc, descriptionImagePath, descriptionVoicePathOne, descriptionVoicePathTwo, subGroupId)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            id,
            serverId,
            orderIndex,
            serverSync,
            title,
            videoUrl,
            imagePath,
            storyTitle,
            storyDesc,
            storyImagePath,
            storyVoicePathOne,
            storyVoicePathTwo,
            descriptionTitle,
            descriptionDesc,
            descriptionImagePath,
            descriptionVoicePathOne,
            descriptionVoicePathTwo,
            subGroupId
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Lesson id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'Lesson id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Lesson Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Lesson>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<Lesson> lessons,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnLesson.rawInsertAll(
        'INSERT OR REPLACE INTO lesson (id, serverId, orderIndex, serverSync, title, videoUrl, imagePath, storyTitle, storyDesc, storyImagePath, storyVoicePathOne, storyVoicePathTwo, descriptionTitle, descriptionDesc, descriptionImagePath, descriptionVoicePathOne, descriptionVoicePathTwo, subGroupId)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
        lessons,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes Lesson

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Lesson invoked (id=$id)');
    var result = BoolResult(success: false);
    {
      result =
          await TblCard().select().lessonId.equals(id).and.delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnLesson
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnLesson.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [Lesson] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  LessonFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return LessonFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  LessonFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return LessonFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    subGroupId = subGroupId ?? 0;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion lesson

// region LessonField
class LessonField extends FilterBase {
  LessonField(LessonFilterBuilder lessonFB) : super(lessonFB);

  @override
  LessonFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as LessonFilterBuilder;
  }

  @override
  LessonFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as LessonFilterBuilder;
  }

  @override
  LessonFilterBuilder isNull() {
    return super.isNull() as LessonFilterBuilder;
  }

  @override
  LessonFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as LessonFilterBuilder;
  }

  @override
  LessonFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as LessonFilterBuilder;
  }

  @override
  LessonFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as LessonFilterBuilder;
  }

  @override
  LessonFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as LessonFilterBuilder;
  }

  @override
  LessonFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as LessonFilterBuilder;
  }

  @override
  LessonFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as LessonFilterBuilder;
  }

  @override
  LessonFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as LessonFilterBuilder;
  }

  @override
  LessonFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as LessonFilterBuilder;
  }

  @override
  LessonFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as LessonFilterBuilder;
  }

  @override
  LessonField get not {
    return super.not as LessonField;
  }
}
// endregion LessonField

// region LessonFilterBuilder
class LessonFilterBuilder extends ConjunctionBase {
  LessonFilterBuilder(Lesson obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnLesson = obj._mnLesson;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  LessonManager? _mnLesson;

  /// put the sql keyword 'AND'
  @override
  LessonFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  LessonFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  LessonFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  LessonFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  LessonFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  LessonFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  LessonFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  LessonFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  LessonFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  LessonFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  LessonFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  LessonField _setField(LessonField? field, String colName, DbType dbtype) {
    return LessonField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  LessonField? _id;
  LessonField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  LessonField? _serverId;
  LessonField get serverId {
    return _serverId = _setField(_serverId, 'serverId', DbType.integer);
  }

  LessonField? _orderIndex;
  LessonField get orderIndex {
    return _orderIndex = _setField(_orderIndex, 'orderIndex', DbType.integer);
  }

  LessonField? _serverSync;
  LessonField get serverSync {
    return _serverSync = _setField(_serverSync, 'serverSync', DbType.bool);
  }

  LessonField? _title;
  LessonField get title {
    return _title = _setField(_title, 'title', DbType.text);
  }

  LessonField? _videoUrl;
  LessonField get videoUrl {
    return _videoUrl = _setField(_videoUrl, 'videoUrl', DbType.text);
  }

  LessonField? _imagePath;
  LessonField get imagePath {
    return _imagePath = _setField(_imagePath, 'imagePath', DbType.text);
  }

  LessonField? _storyTitle;
  LessonField get storyTitle {
    return _storyTitle = _setField(_storyTitle, 'storyTitle', DbType.text);
  }

  LessonField? _storyDesc;
  LessonField get storyDesc {
    return _storyDesc = _setField(_storyDesc, 'storyDesc', DbType.text);
  }

  LessonField? _storyImagePath;
  LessonField get storyImagePath {
    return _storyImagePath =
        _setField(_storyImagePath, 'storyImagePath', DbType.text);
  }

  LessonField? _storyVoicePathOne;
  LessonField get storyVoicePathOne {
    return _storyVoicePathOne =
        _setField(_storyVoicePathOne, 'storyVoicePathOne', DbType.text);
  }

  LessonField? _storyVoicePathTwo;
  LessonField get storyVoicePathTwo {
    return _storyVoicePathTwo =
        _setField(_storyVoicePathTwo, 'storyVoicePathTwo', DbType.text);
  }

  LessonField? _descriptionTitle;
  LessonField get descriptionTitle {
    return _descriptionTitle =
        _setField(_descriptionTitle, 'descriptionTitle', DbType.text);
  }

  LessonField? _descriptionDesc;
  LessonField get descriptionDesc {
    return _descriptionDesc =
        _setField(_descriptionDesc, 'descriptionDesc', DbType.text);
  }

  LessonField? _descriptionImagePath;
  LessonField get descriptionImagePath {
    return _descriptionImagePath =
        _setField(_descriptionImagePath, 'descriptionImagePath', DbType.text);
  }

  LessonField? _descriptionVoicePathOne;
  LessonField get descriptionVoicePathOne {
    return _descriptionVoicePathOne = _setField(
        _descriptionVoicePathOne, 'descriptionVoicePathOne', DbType.text);
  }

  LessonField? _descriptionVoicePathTwo;
  LessonField get descriptionVoicePathTwo {
    return _descriptionVoicePathTwo = _setField(
        _descriptionVoicePathTwo, 'descriptionVoicePathTwo', DbType.text);
  }

  LessonField? _subGroupId;
  LessonField get subGroupId {
    return _subGroupId = _setField(_subGroupId, 'subGroupId', DbType.integer);
  }

  /// Deletes List<Lesson> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);
    // Delete sub records where in (TblCard) according to DeleteRule.CASCADE
    final idListTblCardBYlessonId = toListPrimaryKeySQL(false);
    final resTblCardBYlessonId = await TblCard()
        .select()
        .where('lessonId IN (${idListTblCardBYlessonId['sql']})',
            parameterValue: idListTblCardBYlessonId['args'])
        .delete(hardDelete);
    if (!resTblCardBYlessonId.success) {
      return resTblCardBYlessonId;
    }

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnLesson!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnLesson!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from lesson ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnLesson!.updateBatch(qparams, values);
  }

  /// This method always returns [Lesson] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Lesson?
  @override
  Future<Lesson?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnLesson!.toList(qparams);
    final data = await objFuture;
    Lesson? obj;
    if (data.isNotEmpty) {
      obj = Lesson.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('lesson.plTblCards') && */ (preloadFields ==
                null ||
            preloadFields.contains('plTblCards'))) {
          /*_loadedfields!.add('lesson.plTblCards'); */ obj.plTblCards =
              obj.plTblCards ??
                  await obj.getTblCards()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plSubGroup'))) {
          obj.plSubGroup =
              obj.plSubGroup ?? await obj.getSubGroup(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Lesson]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Lesson?
  @override
  Future<Lesson> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Lesson();
  }

  /// This method returns int. [Lesson]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? lessonCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final lessonsFuture = await _mnLesson!.toList(qparams);
    final int count = lessonsFuture[0]['CNT'] as int;
    if (lessonCount != null) {
      lessonCount(count);
    }
    return count;
  }

  /// This method returns List<Lesson> [Lesson]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Lesson>
  @override
  Future<List<Lesson>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Lesson> lessonsData = await Lesson.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return lessonsData;
  }

  /// This method returns Json String [Lesson]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Lesson]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Lesson]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnLesson!.toList(qparams);
  }

  /// Returns List<DropdownMenuItem<Lesson>>
  Future<List<DropdownMenuItem<Lesson>>> toDropDownMenu(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<Lesson>> o)?
          dropDownMenu]) async {
    buildParameters();
    final lessonsFuture = _mnLesson!.toList(qparams);

    final data = await lessonsFuture;
    final int count = data.length;
    final List<DropdownMenuItem<Lesson>> items = []..add(DropdownMenuItem(
        value: Lesson(),
        child: Text('-'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: Lesson.fromMap(data[i] as Map<String, dynamic>),
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// Returns List<DropdownMenuItem<int>>
  Future<List<DropdownMenuItem<int>>> toDropDownMenuInt(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<int>> o)?
          dropDownMenu]) async {
    buildParameters();
    qparams.selectColumns = ['id', displayTextColumn];
    final lessonsFuture = _mnLesson!.toList(qparams);

    final data = await lessonsFuture;
    final int count = data.length;
    final List<DropdownMenuItem<int>> items = []..add(DropdownMenuItem(
        value: 0,
        child: Text('-'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: data[i]['id'] as int,
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Lesson]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM lesson WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnLesson!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Lesson]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnLesson!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Lesson.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnLesson!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion LessonFilterBuilder

// region LessonFields
class LessonFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fServerId;
  static TableField get serverId {
    return _fServerId = _fServerId ??
        SqlSyntax.setField(_fServerId, 'serverId', DbType.integer);
  }

  static TableField? _fOrderIndex;
  static TableField get orderIndex {
    return _fOrderIndex = _fOrderIndex ??
        SqlSyntax.setField(_fOrderIndex, 'orderIndex', DbType.integer);
  }

  static TableField? _fServerSync;
  static TableField get serverSync {
    return _fServerSync = _fServerSync ??
        SqlSyntax.setField(_fServerSync, 'serverSync', DbType.bool);
  }

  static TableField? _fTitle;
  static TableField get title {
    return _fTitle =
        _fTitle ?? SqlSyntax.setField(_fTitle, 'title', DbType.text);
  }

  static TableField? _fVideoUrl;
  static TableField get videoUrl {
    return _fVideoUrl =
        _fVideoUrl ?? SqlSyntax.setField(_fVideoUrl, 'videoUrl', DbType.text);
  }

  static TableField? _fImagePath;
  static TableField get imagePath {
    return _fImagePath = _fImagePath ??
        SqlSyntax.setField(_fImagePath, 'imagePath', DbType.text);
  }

  static TableField? _fStoryTitle;
  static TableField get storyTitle {
    return _fStoryTitle = _fStoryTitle ??
        SqlSyntax.setField(_fStoryTitle, 'storyTitle', DbType.text);
  }

  static TableField? _fStoryDesc;
  static TableField get storyDesc {
    return _fStoryDesc = _fStoryDesc ??
        SqlSyntax.setField(_fStoryDesc, 'storyDesc', DbType.text);
  }

  static TableField? _fStoryImagePath;
  static TableField get storyImagePath {
    return _fStoryImagePath = _fStoryImagePath ??
        SqlSyntax.setField(_fStoryImagePath, 'storyImagePath', DbType.text);
  }

  static TableField? _fStoryVoicePathOne;
  static TableField get storyVoicePathOne {
    return _fStoryVoicePathOne = _fStoryVoicePathOne ??
        SqlSyntax.setField(
            _fStoryVoicePathOne, 'storyVoicePathOne', DbType.text);
  }

  static TableField? _fStoryVoicePathTwo;
  static TableField get storyVoicePathTwo {
    return _fStoryVoicePathTwo = _fStoryVoicePathTwo ??
        SqlSyntax.setField(
            _fStoryVoicePathTwo, 'storyVoicePathTwo', DbType.text);
  }

  static TableField? _fDescriptionTitle;
  static TableField get descriptionTitle {
    return _fDescriptionTitle = _fDescriptionTitle ??
        SqlSyntax.setField(_fDescriptionTitle, 'descriptionTitle', DbType.text);
  }

  static TableField? _fDescriptionDesc;
  static TableField get descriptionDesc {
    return _fDescriptionDesc = _fDescriptionDesc ??
        SqlSyntax.setField(_fDescriptionDesc, 'descriptionDesc', DbType.text);
  }

  static TableField? _fDescriptionImagePath;
  static TableField get descriptionImagePath {
    return _fDescriptionImagePath = _fDescriptionImagePath ??
        SqlSyntax.setField(
            _fDescriptionImagePath, 'descriptionImagePath', DbType.text);
  }

  static TableField? _fDescriptionVoicePathOne;
  static TableField get descriptionVoicePathOne {
    return _fDescriptionVoicePathOne = _fDescriptionVoicePathOne ??
        SqlSyntax.setField(
            _fDescriptionVoicePathOne, 'descriptionVoicePathOne', DbType.text);
  }

  static TableField? _fDescriptionVoicePathTwo;
  static TableField get descriptionVoicePathTwo {
    return _fDescriptionVoicePathTwo = _fDescriptionVoicePathTwo ??
        SqlSyntax.setField(
            _fDescriptionVoicePathTwo, 'descriptionVoicePathTwo', DbType.text);
  }

  static TableField? _fSubGroupId;
  static TableField get subGroupId {
    return _fSubGroupId = _fSubGroupId ??
        SqlSyntax.setField(_fSubGroupId, 'subGroupId', DbType.integer);
  }
}
// endregion LessonFields

//region LessonManager
class LessonManager extends SqfEntityProvider {
  LessonManager()
      : super(MyDbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'lesson';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion LessonManager
// region TblCard
class TblCard extends TableBase {
  TblCard(
      {this.id,
      this.serverId,
      this.orderIndex,
      this.serverSync,
      this.videoUrl,
      this.spellChecker,
      this.question,
      this.questionVoicePath,
      this.ratio,
      this.reply,
      this.replyVoicePath,
      this.description,
      this.descriptionVoicePath,
      this.imagePath,
      this.dateCreated,
      this.reviewStart,
      this.examDone,
      this.autoPlay,
      this.autoRecord,
      this.boxNumber,
      this.boxVisibleDate,
      this.lessonId}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  TblCard.withFields(
      this.serverId,
      this.orderIndex,
      this.serverSync,
      this.videoUrl,
      this.spellChecker,
      this.question,
      this.questionVoicePath,
      this.ratio,
      this.reply,
      this.replyVoicePath,
      this.description,
      this.descriptionVoicePath,
      this.imagePath,
      this.dateCreated,
      this.reviewStart,
      this.examDone,
      this.autoPlay,
      this.autoRecord,
      this.boxNumber,
      this.boxVisibleDate,
      this.lessonId) {
    _setDefaultValues();
  }
  TblCard.withId(
      this.id,
      this.serverId,
      this.orderIndex,
      this.serverSync,
      this.videoUrl,
      this.spellChecker,
      this.question,
      this.questionVoicePath,
      this.ratio,
      this.reply,
      this.replyVoicePath,
      this.description,
      this.descriptionVoicePath,
      this.imagePath,
      this.dateCreated,
      this.reviewStart,
      this.examDone,
      this.autoPlay,
      this.autoRecord,
      this.boxNumber,
      this.boxVisibleDate,
      this.lessonId) {
    _setDefaultValues();
  }
  // fromMap v2.0
  TblCard.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['serverId'] != null) {
      serverId = int.tryParse(o['serverId'].toString());
    }
    if (o['orderIndex'] != null) {
      orderIndex = int.tryParse(o['orderIndex'].toString());
    }
    if (o['serverSync'] != null) {
      serverSync = o['serverSync'].toString() == '1' ||
          o['serverSync'].toString() == 'true';
    }
    if (o['videoUrl'] != null) {
      videoUrl = o['videoUrl'].toString();
    }
    if (o['spellChecker'] != null) {
      spellChecker = o['spellChecker'].toString() == '1' ||
          o['spellChecker'].toString() == 'true';
    }
    if (o['question'] != null) {
      question = o['question'].toString();
    }
    if (o['questionVoicePath'] != null) {
      questionVoicePath = o['questionVoicePath'].toString();
    }
    if (o['ratio'] != null) {
      ratio = double.tryParse(o['ratio'].toString());
    }
    if (o['reply'] != null) {
      reply = o['reply'].toString();
    }
    if (o['replyVoicePath'] != null) {
      replyVoicePath = o['replyVoicePath'].toString();
    }
    if (o['description'] != null) {
      description = o['description'].toString();
    }
    if (o['descriptionVoicePath'] != null) {
      descriptionVoicePath = o['descriptionVoicePath'].toString();
    }
    if (o['imagePath'] != null) {
      imagePath = o['imagePath'].toString();
    }
    if (o['dateCreated'] != null) {
      dateCreated = int.tryParse(o['dateCreated'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['dateCreated'].toString())!)
          : DateTime.tryParse(o['dateCreated'].toString());
    }
    if (o['reviewStart'] != null) {
      reviewStart = o['reviewStart'].toString() == '1' ||
          o['reviewStart'].toString() == 'true';
    }
    if (o['examDone'] != null) {
      examDone =
          o['examDone'].toString() == '1' || o['examDone'].toString() == 'true';
    }
    if (o['autoPlay'] != null) {
      autoPlay =
          o['autoPlay'].toString() == '1' || o['autoPlay'].toString() == 'true';
    }
    if (o['autoRecord'] != null) {
      autoRecord = o['autoRecord'].toString() == '1' ||
          o['autoRecord'].toString() == 'true';
    }
    if (o['boxNumber'] != null) {
      boxNumber = int.tryParse(o['boxNumber'].toString());
    }
    if (o['boxVisibleDate'] != null) {
      boxVisibleDate = int.tryParse(o['boxVisibleDate'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['boxVisibleDate'].toString())!)
          : DateTime.tryParse(o['boxVisibleDate'].toString());
    }
    lessonId = int.tryParse(o['lessonId'].toString());

    // RELATIONSHIPS FromMAP
    plLesson = o['lesson'] != null
        ? Lesson.fromMap(o['lesson'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP
  }
  // FIELDS (TblCard)
  int? id;
  int? serverId;
  int? orderIndex;
  bool? serverSync;
  String? videoUrl;
  bool? spellChecker;
  String? question;
  String? questionVoicePath;
  double? ratio;
  String? reply;
  String? replyVoicePath;
  String? description;
  String? descriptionVoicePath;
  String? imagePath;
  DateTime? dateCreated;
  bool? reviewStart;
  bool? examDone;
  bool? autoPlay;
  bool? autoRecord;
  int? boxNumber;
  DateTime? boxVisibleDate;
  int? lessonId;

  // end FIELDS (TblCard)

// RELATIONSHIPS (TblCard)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plLesson', 'plField2'..]) or so on..
  Lesson? plLesson;

  /// get Lesson By LessonId
  Future<Lesson?> getLesson(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await Lesson().getById(lessonId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (TblCard)

// COLLECTIONS & VIRTUALS (TblCard)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plTablehistories', 'plField2'..]) or so on..
  List<Tablehistory>? plTablehistories;

  /// get Tablehistory(s) filtered by id=tblCardId
  TablehistoryFilterBuilder? getTablehistories(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return Tablehistory()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .tblCardId
        .equals(id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (TblCard)

  static const bool _softDeleteActivated = false;
  TblCardManager? __mnTblCard;

  TblCardManager get _mnTblCard {
    return __mnTblCard = __mnTblCard ?? TblCardManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (serverId != null || !forView) {
      map['serverId'] = serverId;
    }
    if (orderIndex != null || !forView) {
      map['orderIndex'] = orderIndex;
    }
    if (serverSync != null) {
      map['serverSync'] = forQuery ? (serverSync! ? 1 : 0) : serverSync;
    } else if (serverSync != null || !forView) {
      map['serverSync'] = null;
    }
    if (videoUrl != null || !forView) {
      map['videoUrl'] = videoUrl;
    }
    if (spellChecker != null) {
      map['spellChecker'] = forQuery ? (spellChecker! ? 1 : 0) : spellChecker;
    } else if (spellChecker != null || !forView) {
      map['spellChecker'] = null;
    }
    if (question != null || !forView) {
      map['question'] = question;
    }
    if (questionVoicePath != null || !forView) {
      map['questionVoicePath'] = questionVoicePath;
    }
    if (ratio != null || !forView) {
      map['ratio'] = ratio;
    }
    if (reply != null || !forView) {
      map['reply'] = reply;
    }
    if (replyVoicePath != null || !forView) {
      map['replyVoicePath'] = replyVoicePath;
    }
    if (description != null || !forView) {
      map['description'] = description;
    }
    if (descriptionVoicePath != null || !forView) {
      map['descriptionVoicePath'] = descriptionVoicePath;
    }
    if (imagePath != null || !forView) {
      map['imagePath'] = imagePath;
    }
    if (dateCreated != null) {
      map['dateCreated'] = forJson
          ? dateCreated!.toString()
          : forQuery
              ? dateCreated!.millisecondsSinceEpoch
              : dateCreated;
    } else if (dateCreated != null || !forView) {
      map['dateCreated'] = null;
    }
    if (reviewStart != null) {
      map['reviewStart'] = forQuery ? (reviewStart! ? 1 : 0) : reviewStart;
    } else if (reviewStart != null || !forView) {
      map['reviewStart'] = null;
    }
    if (examDone != null) {
      map['examDone'] = forQuery ? (examDone! ? 1 : 0) : examDone;
    } else if (examDone != null || !forView) {
      map['examDone'] = null;
    }
    if (autoPlay != null) {
      map['autoPlay'] = forQuery ? (autoPlay! ? 1 : 0) : autoPlay;
    } else if (autoPlay != null || !forView) {
      map['autoPlay'] = null;
    }
    if (autoRecord != null) {
      map['autoRecord'] = forQuery ? (autoRecord! ? 1 : 0) : autoRecord;
    } else if (autoRecord != null || !forView) {
      map['autoRecord'] = null;
    }
    if (boxNumber != null || !forView) {
      map['boxNumber'] = boxNumber;
    }
    if (boxVisibleDate != null) {
      map['boxVisibleDate'] = forJson
          ? boxVisibleDate!.toString()
          : forQuery
              ? boxVisibleDate!.millisecondsSinceEpoch
              : boxVisibleDate;
    } else if (boxVisibleDate != null || !forView) {
      map['boxVisibleDate'] = null;
    }
    if (lessonId != null) {
      map['lessonId'] = forView
          ? plLesson == null
              ? lessonId
              : plLesson!.title
          : lessonId;
    } else if (lessonId != null || !forView) {
      map['lessonId'] = null;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (serverId != null || !forView) {
      map['serverId'] = serverId;
    }
    if (orderIndex != null || !forView) {
      map['orderIndex'] = orderIndex;
    }
    if (serverSync != null) {
      map['serverSync'] = forQuery ? (serverSync! ? 1 : 0) : serverSync;
    } else if (serverSync != null || !forView) {
      map['serverSync'] = null;
    }
    if (videoUrl != null || !forView) {
      map['videoUrl'] = videoUrl;
    }
    if (spellChecker != null) {
      map['spellChecker'] = forQuery ? (spellChecker! ? 1 : 0) : spellChecker;
    } else if (spellChecker != null || !forView) {
      map['spellChecker'] = null;
    }
    if (question != null || !forView) {
      map['question'] = question;
    }
    if (questionVoicePath != null || !forView) {
      map['questionVoicePath'] = questionVoicePath;
    }
    if (ratio != null || !forView) {
      map['ratio'] = ratio;
    }
    if (reply != null || !forView) {
      map['reply'] = reply;
    }
    if (replyVoicePath != null || !forView) {
      map['replyVoicePath'] = replyVoicePath;
    }
    if (description != null || !forView) {
      map['description'] = description;
    }
    if (descriptionVoicePath != null || !forView) {
      map['descriptionVoicePath'] = descriptionVoicePath;
    }
    if (imagePath != null || !forView) {
      map['imagePath'] = imagePath;
    }
    if (dateCreated != null) {
      map['dateCreated'] = forJson
          ? dateCreated!.toString()
          : forQuery
              ? dateCreated!.millisecondsSinceEpoch
              : dateCreated;
    } else if (dateCreated != null || !forView) {
      map['dateCreated'] = null;
    }
    if (reviewStart != null) {
      map['reviewStart'] = forQuery ? (reviewStart! ? 1 : 0) : reviewStart;
    } else if (reviewStart != null || !forView) {
      map['reviewStart'] = null;
    }
    if (examDone != null) {
      map['examDone'] = forQuery ? (examDone! ? 1 : 0) : examDone;
    } else if (examDone != null || !forView) {
      map['examDone'] = null;
    }
    if (autoPlay != null) {
      map['autoPlay'] = forQuery ? (autoPlay! ? 1 : 0) : autoPlay;
    } else if (autoPlay != null || !forView) {
      map['autoPlay'] = null;
    }
    if (autoRecord != null) {
      map['autoRecord'] = forQuery ? (autoRecord! ? 1 : 0) : autoRecord;
    } else if (autoRecord != null || !forView) {
      map['autoRecord'] = null;
    }
    if (boxNumber != null || !forView) {
      map['boxNumber'] = boxNumber;
    }
    if (boxVisibleDate != null) {
      map['boxVisibleDate'] = forJson
          ? boxVisibleDate!.toString()
          : forQuery
              ? boxVisibleDate!.millisecondsSinceEpoch
              : boxVisibleDate;
    } else if (boxVisibleDate != null || !forView) {
      map['boxVisibleDate'] = null;
    }
    if (lessonId != null) {
      map['lessonId'] = forView
          ? plLesson == null
              ? lessonId
              : plLesson!.title
          : lessonId;
    } else if (lessonId != null || !forView) {
      map['lessonId'] = null;
    }

// COLLECTIONS (TblCard)
    if (!forQuery) {
      map['Tablehistories'] = await getTablehistories()!.toMapList();
    }
// END COLLECTIONS (TblCard)

    return map;
  }

  /// This method returns Json String [TblCard]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [TblCard]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      serverId,
      orderIndex,
      serverSync,
      videoUrl,
      spellChecker,
      question,
      questionVoicePath,
      ratio,
      reply,
      replyVoicePath,
      description,
      descriptionVoicePath,
      imagePath,
      dateCreated != null ? dateCreated!.millisecondsSinceEpoch : null,
      reviewStart,
      examDone,
      autoPlay,
      autoRecord,
      boxNumber,
      boxVisibleDate != null ? boxVisibleDate!.millisecondsSinceEpoch : null,
      lessonId
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      id,
      serverId,
      orderIndex,
      serverSync,
      videoUrl,
      spellChecker,
      question,
      questionVoicePath,
      ratio,
      reply,
      replyVoicePath,
      description,
      descriptionVoicePath,
      imagePath,
      dateCreated != null ? dateCreated!.millisecondsSinceEpoch : null,
      reviewStart,
      examDone,
      autoPlay,
      autoRecord,
      boxNumber,
      boxVisibleDate != null ? boxVisibleDate!.millisecondsSinceEpoch : null,
      lessonId
    ];
  }

  static Future<List<TblCard>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR TblCard.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<TblCard>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <TblCard>[];
    try {
      objList = list
          .map((tblcard) => TblCard.fromMap(tblcard as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR TblCard.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<TblCard>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<TblCard> objList = <TblCard>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = TblCard.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('tblCard.plTablehistories') && */ (preloadFields ==
                null ||
            preloadFields.contains('plTablehistories'))) {
          /*_loadedfields!.add('tblCard.plTablehistories'); */ obj
                  .plTablehistories =
              obj.plTablehistories ??
                  await obj.getTablehistories()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plLesson'))) {
          obj.plLesson =
              obj.plLesson ?? await obj.getLesson(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns TblCard by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [TblCard] if exist, otherwise returns null
  Future<TblCard?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    TblCard? obj;
    final data = await _mnTblCard.getById([id]);
    if (data.length != 0) {
      obj = TblCard.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('tblCard.plTablehistories') && */ (preloadFields ==
                null ||
            preloadFields.contains('plTablehistories'))) {
          /*_loadedfields!.add('tblCard.plTablehistories'); */ obj
                  .plTablehistories =
              obj.plTablehistories ??
                  await obj.getTablehistories()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plLesson'))) {
          obj.plLesson =
              obj.plLesson ?? await obj.getLesson(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (TblCard) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnTblCard.insert(this, ignoreBatch);
    } else {
      await _mnTblCard.update(this);
    }

    return id;
  }

  /// Saves the (TblCard) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnTblCard.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnTblCard.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs TblCard. Returns a new Primary Key value of TblCard

  /// <returns>Returns a new Primary Key value of TblCard
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<TblCard> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<TblCard> tblcards,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await MyDbModel().batchStart();
    for (final obj in tblcards) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await MyDbModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < tblcards.length; i++) {
        if (tblcards[i].id == null) {
          tblcards[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnTblCard.rawInsert(
          'INSERT OR REPLACE INTO tblCard (id, serverId, orderIndex, serverSync, videoUrl, spellChecker, question, questionVoicePath, ratio, reply, replyVoicePath, description, descriptionVoicePath, imagePath, dateCreated, reviewStart, examDone, autoPlay, autoRecord, boxNumber, boxVisibleDate, lessonId)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            id,
            serverId,
            orderIndex,
            serverSync,
            videoUrl,
            spellChecker,
            question,
            questionVoicePath,
            ratio,
            reply,
            replyVoicePath,
            description,
            descriptionVoicePath,
            imagePath,
            dateCreated != null ? dateCreated!.millisecondsSinceEpoch : null,
            reviewStart,
            examDone,
            autoPlay,
            autoRecord,
            boxNumber,
            boxVisibleDate != null
                ? boxVisibleDate!.millisecondsSinceEpoch
                : null,
            lessonId
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'TblCard id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'TblCard id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'TblCard Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<TblCard>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<TblCard> tblcards,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnTblCard.rawInsertAll(
        'INSERT OR REPLACE INTO tblCard (id, serverId, orderIndex, serverSync, videoUrl, spellChecker, question, questionVoicePath, ratio, reply, replyVoicePath, description, descriptionVoicePath, imagePath, dateCreated, reviewStart, examDone, autoPlay, autoRecord, boxNumber, boxVisibleDate, lessonId)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
        tblcards,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes TblCard

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete TblCard invoked (id=$id)');
    var result = BoolResult(success: false);
    {
      result = await Tablehistory()
          .select()
          .tblCardId
          .equals(id)
          .and
          .delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnTblCard
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnTblCard.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [TblCard] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  TblCardFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return TblCardFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  TblCardFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return TblCardFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    spellChecker = spellChecker ?? false;
    reviewStart = reviewStart ?? false;
    examDone = examDone ?? false;
    autoPlay = autoPlay ?? true;
    autoRecord = autoRecord ?? true;
    boxNumber = boxNumber ?? 0;
    lessonId = lessonId ?? 0;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion tblcard

// region TblCardField
class TblCardField extends FilterBase {
  TblCardField(TblCardFilterBuilder tblcardFB) : super(tblcardFB);

  @override
  TblCardFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as TblCardFilterBuilder;
  }

  @override
  TblCardFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as TblCardFilterBuilder;
  }

  @override
  TblCardFilterBuilder isNull() {
    return super.isNull() as TblCardFilterBuilder;
  }

  @override
  TblCardFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as TblCardFilterBuilder;
  }

  @override
  TblCardFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as TblCardFilterBuilder;
  }

  @override
  TblCardFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as TblCardFilterBuilder;
  }

  @override
  TblCardFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as TblCardFilterBuilder;
  }

  @override
  TblCardFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as TblCardFilterBuilder;
  }

  @override
  TblCardFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as TblCardFilterBuilder;
  }

  @override
  TblCardFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as TblCardFilterBuilder;
  }

  @override
  TblCardFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as TblCardFilterBuilder;
  }

  @override
  TblCardFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as TblCardFilterBuilder;
  }

  @override
  TblCardField get not {
    return super.not as TblCardField;
  }
}
// endregion TblCardField

// region TblCardFilterBuilder
class TblCardFilterBuilder extends ConjunctionBase {
  TblCardFilterBuilder(TblCard obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnTblCard = obj._mnTblCard;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  TblCardManager? _mnTblCard;

  /// put the sql keyword 'AND'
  @override
  TblCardFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  TblCardFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  TblCardFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  TblCardFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  TblCardFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  TblCardFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  TblCardFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  TblCardFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  TblCardFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  TblCardFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  TblCardFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  TblCardField _setField(TblCardField? field, String colName, DbType dbtype) {
    return TblCardField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  TblCardField? _id;
  TblCardField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  TblCardField? _serverId;
  TblCardField get serverId {
    return _serverId = _setField(_serverId, 'serverId', DbType.integer);
  }

  TblCardField? _orderIndex;
  TblCardField get orderIndex {
    return _orderIndex = _setField(_orderIndex, 'orderIndex', DbType.integer);
  }

  TblCardField? _serverSync;
  TblCardField get serverSync {
    return _serverSync = _setField(_serverSync, 'serverSync', DbType.bool);
  }

  TblCardField? _videoUrl;
  TblCardField get videoUrl {
    return _videoUrl = _setField(_videoUrl, 'videoUrl', DbType.text);
  }

  TblCardField? _spellChecker;
  TblCardField get spellChecker {
    return _spellChecker =
        _setField(_spellChecker, 'spellChecker', DbType.bool);
  }

  TblCardField? _question;
  TblCardField get question {
    return _question = _setField(_question, 'question', DbType.text);
  }

  TblCardField? _questionVoicePath;
  TblCardField get questionVoicePath {
    return _questionVoicePath =
        _setField(_questionVoicePath, 'questionVoicePath', DbType.text);
  }

  TblCardField? _ratio;
  TblCardField get ratio {
    return _ratio = _setField(_ratio, 'ratio', DbType.real);
  }

  TblCardField? _reply;
  TblCardField get reply {
    return _reply = _setField(_reply, 'reply', DbType.text);
  }

  TblCardField? _replyVoicePath;
  TblCardField get replyVoicePath {
    return _replyVoicePath =
        _setField(_replyVoicePath, 'replyVoicePath', DbType.text);
  }

  TblCardField? _description;
  TblCardField get description {
    return _description = _setField(_description, 'description', DbType.text);
  }

  TblCardField? _descriptionVoicePath;
  TblCardField get descriptionVoicePath {
    return _descriptionVoicePath =
        _setField(_descriptionVoicePath, 'descriptionVoicePath', DbType.text);
  }

  TblCardField? _imagePath;
  TblCardField get imagePath {
    return _imagePath = _setField(_imagePath, 'imagePath', DbType.text);
  }

  TblCardField? _dateCreated;
  TblCardField get dateCreated {
    return _dateCreated =
        _setField(_dateCreated, 'dateCreated', DbType.datetime);
  }

  TblCardField? _reviewStart;
  TblCardField get reviewStart {
    return _reviewStart = _setField(_reviewStart, 'reviewStart', DbType.bool);
  }

  TblCardField? _examDone;
  TblCardField get examDone {
    return _examDone = _setField(_examDone, 'examDone', DbType.bool);
  }

  TblCardField? _autoPlay;
  TblCardField get autoPlay {
    return _autoPlay = _setField(_autoPlay, 'autoPlay', DbType.bool);
  }

  TblCardField? _autoRecord;
  TblCardField get autoRecord {
    return _autoRecord = _setField(_autoRecord, 'autoRecord', DbType.bool);
  }

  TblCardField? _boxNumber;
  TblCardField get boxNumber {
    return _boxNumber = _setField(_boxNumber, 'boxNumber', DbType.integer);
  }

  TblCardField? _boxVisibleDate;
  TblCardField get boxVisibleDate {
    return _boxVisibleDate =
        _setField(_boxVisibleDate, 'boxVisibleDate', DbType.datetime);
  }

  TblCardField? _lessonId;
  TblCardField get lessonId {
    return _lessonId = _setField(_lessonId, 'lessonId', DbType.integer);
  }

  /// Deletes List<TblCard> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);
    // Delete sub records where in (Tablehistory) according to DeleteRule.CASCADE
    final idListTablehistoryBYtblCardId = toListPrimaryKeySQL(false);
    final resTablehistoryBYtblCardId = await Tablehistory()
        .select()
        .where('tblCardId IN (${idListTablehistoryBYtblCardId['sql']})',
            parameterValue: idListTablehistoryBYtblCardId['args'])
        .delete(hardDelete);
    if (!resTablehistoryBYtblCardId.success) {
      return resTablehistoryBYtblCardId;
    }

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnTblCard!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnTblCard!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from tblCard ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnTblCard!.updateBatch(qparams, values);
  }

  /// This method always returns [TblCard] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> TblCard?
  @override
  Future<TblCard?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnTblCard!.toList(qparams);
    final data = await objFuture;
    TblCard? obj;
    if (data.isNotEmpty) {
      obj = TblCard.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('tblCard.plTablehistories') && */ (preloadFields ==
                null ||
            preloadFields.contains('plTablehistories'))) {
          /*_loadedfields!.add('tblCard.plTablehistories'); */ obj
                  .plTablehistories =
              obj.plTablehistories ??
                  await obj.getTablehistories()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plLesson'))) {
          obj.plLesson =
              obj.plLesson ?? await obj.getLesson(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [TblCard]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> TblCard?
  @override
  Future<TblCard> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        TblCard();
  }

  /// This method returns int. [TblCard]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? tblcardCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final tblcardsFuture = await _mnTblCard!.toList(qparams);
    final int count = tblcardsFuture[0]['CNT'] as int;
    if (tblcardCount != null) {
      tblcardCount(count);
    }
    return count;
  }

  /// This method returns List<TblCard> [TblCard]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<TblCard>
  @override
  Future<List<TblCard>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<TblCard> tblcardsData = await TblCard.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return tblcardsData;
  }

  /// This method returns Json String [TblCard]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [TblCard]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [TblCard]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnTblCard!.toList(qparams);
  }

  /// Returns List<DropdownMenuItem<TblCard>>
  Future<List<DropdownMenuItem<TblCard>>> toDropDownMenu(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<TblCard>> o)?
          dropDownMenu]) async {
    buildParameters();
    final tblcardsFuture = _mnTblCard!.toList(qparams);

    final data = await tblcardsFuture;
    final int count = data.length;
    final List<DropdownMenuItem<TblCard>> items = []..add(DropdownMenuItem(
        value: TblCard(),
        child: Text('-'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: TblCard.fromMap(data[i] as Map<String, dynamic>),
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// Returns List<DropdownMenuItem<int>>
  Future<List<DropdownMenuItem<int>>> toDropDownMenuInt(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<int>> o)?
          dropDownMenu]) async {
    buildParameters();
    qparams.selectColumns = ['id', displayTextColumn];
    final tblcardsFuture = _mnTblCard!.toList(qparams);

    final data = await tblcardsFuture;
    final int count = data.length;
    final List<DropdownMenuItem<int>> items = []..add(DropdownMenuItem(
        value: 0,
        child: Text('-'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: data[i]['id'] as int,
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [TblCard]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM tblCard WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnTblCard!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [TblCard]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnTblCard!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await TblCard.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnTblCard!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion TblCardFilterBuilder

// region TblCardFields
class TblCardFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fServerId;
  static TableField get serverId {
    return _fServerId = _fServerId ??
        SqlSyntax.setField(_fServerId, 'serverId', DbType.integer);
  }

  static TableField? _fOrderIndex;
  static TableField get orderIndex {
    return _fOrderIndex = _fOrderIndex ??
        SqlSyntax.setField(_fOrderIndex, 'orderIndex', DbType.integer);
  }

  static TableField? _fServerSync;
  static TableField get serverSync {
    return _fServerSync = _fServerSync ??
        SqlSyntax.setField(_fServerSync, 'serverSync', DbType.bool);
  }

  static TableField? _fVideoUrl;
  static TableField get videoUrl {
    return _fVideoUrl =
        _fVideoUrl ?? SqlSyntax.setField(_fVideoUrl, 'videoUrl', DbType.text);
  }

  static TableField? _fSpellChecker;
  static TableField get spellChecker {
    return _fSpellChecker = _fSpellChecker ??
        SqlSyntax.setField(_fSpellChecker, 'spellChecker', DbType.bool);
  }

  static TableField? _fQuestion;
  static TableField get question {
    return _fQuestion =
        _fQuestion ?? SqlSyntax.setField(_fQuestion, 'question', DbType.text);
  }

  static TableField? _fQuestionVoicePath;
  static TableField get questionVoicePath {
    return _fQuestionVoicePath = _fQuestionVoicePath ??
        SqlSyntax.setField(
            _fQuestionVoicePath, 'questionVoicePath', DbType.text);
  }

  static TableField? _fRatio;
  static TableField get ratio {
    return _fRatio =
        _fRatio ?? SqlSyntax.setField(_fRatio, 'ratio', DbType.real);
  }

  static TableField? _fReply;
  static TableField get reply {
    return _fReply =
        _fReply ?? SqlSyntax.setField(_fReply, 'reply', DbType.text);
  }

  static TableField? _fReplyVoicePath;
  static TableField get replyVoicePath {
    return _fReplyVoicePath = _fReplyVoicePath ??
        SqlSyntax.setField(_fReplyVoicePath, 'replyVoicePath', DbType.text);
  }

  static TableField? _fDescription;
  static TableField get description {
    return _fDescription = _fDescription ??
        SqlSyntax.setField(_fDescription, 'description', DbType.text);
  }

  static TableField? _fDescriptionVoicePath;
  static TableField get descriptionVoicePath {
    return _fDescriptionVoicePath = _fDescriptionVoicePath ??
        SqlSyntax.setField(
            _fDescriptionVoicePath, 'descriptionVoicePath', DbType.text);
  }

  static TableField? _fImagePath;
  static TableField get imagePath {
    return _fImagePath = _fImagePath ??
        SqlSyntax.setField(_fImagePath, 'imagePath', DbType.text);
  }

  static TableField? _fDateCreated;
  static TableField get dateCreated {
    return _fDateCreated = _fDateCreated ??
        SqlSyntax.setField(_fDateCreated, 'dateCreated', DbType.datetime);
  }

  static TableField? _fReviewStart;
  static TableField get reviewStart {
    return _fReviewStart = _fReviewStart ??
        SqlSyntax.setField(_fReviewStart, 'reviewStart', DbType.bool);
  }

  static TableField? _fExamDone;
  static TableField get examDone {
    return _fExamDone =
        _fExamDone ?? SqlSyntax.setField(_fExamDone, 'examDone', DbType.bool);
  }

  static TableField? _fAutoPlay;
  static TableField get autoPlay {
    return _fAutoPlay =
        _fAutoPlay ?? SqlSyntax.setField(_fAutoPlay, 'autoPlay', DbType.bool);
  }

  static TableField? _fAutoRecord;
  static TableField get autoRecord {
    return _fAutoRecord = _fAutoRecord ??
        SqlSyntax.setField(_fAutoRecord, 'autoRecord', DbType.bool);
  }

  static TableField? _fBoxNumber;
  static TableField get boxNumber {
    return _fBoxNumber = _fBoxNumber ??
        SqlSyntax.setField(_fBoxNumber, 'boxNumber', DbType.integer);
  }

  static TableField? _fBoxVisibleDate;
  static TableField get boxVisibleDate {
    return _fBoxVisibleDate = _fBoxVisibleDate ??
        SqlSyntax.setField(_fBoxVisibleDate, 'boxVisibleDate', DbType.datetime);
  }

  static TableField? _fLessonId;
  static TableField get lessonId {
    return _fLessonId = _fLessonId ??
        SqlSyntax.setField(_fLessonId, 'lessonId', DbType.integer);
  }
}
// endregion TblCardFields

//region TblCardManager
class TblCardManager extends SqfEntityProvider {
  TblCardManager()
      : super(MyDbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'tblCard';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion TblCardManager
// region Tablehistory
class Tablehistory extends TableBase {
  Tablehistory(
      {this.id,
      this.serverId,
      this.serverSync,
      this.replyVoicePath,
      this.reply,
      this.dateQuestion,
      this.resultQuestion,
      this.replyTimeInSecond,
      this.goodTimeInSecond,
      this.beforeBoxNumber,
      this.nextBoxNumber,
      this.tblCardId}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  Tablehistory.withFields(
      this.serverId,
      this.serverSync,
      this.replyVoicePath,
      this.reply,
      this.dateQuestion,
      this.resultQuestion,
      this.replyTimeInSecond,
      this.goodTimeInSecond,
      this.beforeBoxNumber,
      this.nextBoxNumber,
      this.tblCardId) {
    _setDefaultValues();
  }
  Tablehistory.withId(
      this.id,
      this.serverId,
      this.serverSync,
      this.replyVoicePath,
      this.reply,
      this.dateQuestion,
      this.resultQuestion,
      this.replyTimeInSecond,
      this.goodTimeInSecond,
      this.beforeBoxNumber,
      this.nextBoxNumber,
      this.tblCardId) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Tablehistory.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['serverId'] != null) {
      serverId = int.tryParse(o['serverId'].toString());
    }
    if (o['serverSync'] != null) {
      serverSync = o['serverSync'].toString() == '1' ||
          o['serverSync'].toString() == 'true';
    }
    if (o['replyVoicePath'] != null) {
      replyVoicePath = o['replyVoicePath'].toString();
    }
    if (o['reply'] != null) {
      reply = o['reply'].toString();
    }
    if (o['dateQuestion'] != null) {
      dateQuestion = int.tryParse(o['dateQuestion'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['dateQuestion'].toString())!)
          : DateTime.tryParse(o['dateQuestion'].toString());
    }
    if (o['resultQuestion'] != null) {
      resultQuestion = int.tryParse(o['resultQuestion'].toString());
    }
    if (o['replyTimeInSecond'] != null) {
      replyTimeInSecond = int.tryParse(o['replyTimeInSecond'].toString());
    }
    if (o['goodTimeInSecond'] != null) {
      goodTimeInSecond = int.tryParse(o['goodTimeInSecond'].toString());
    }
    if (o['beforeBoxNumber'] != null) {
      beforeBoxNumber = int.tryParse(o['beforeBoxNumber'].toString());
    }
    if (o['nextBoxNumber'] != null) {
      nextBoxNumber = int.tryParse(o['nextBoxNumber'].toString());
    }
    tblCardId = int.tryParse(o['tblCardId'].toString());

    // RELATIONSHIPS FromMAP
    plTblCard = o['tblCard'] != null
        ? TblCard.fromMap(o['tblCard'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP
  }
  // FIELDS (Tablehistory)
  int? id;
  int? serverId;
  bool? serverSync;
  String? replyVoicePath;
  String? reply;
  DateTime? dateQuestion;
  int? resultQuestion;
  int? replyTimeInSecond;
  int? goodTimeInSecond;
  int? beforeBoxNumber;
  int? nextBoxNumber;
  int? tblCardId;

  // end FIELDS (Tablehistory)

// RELATIONSHIPS (Tablehistory)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plTblCard', 'plField2'..]) or so on..
  TblCard? plTblCard;

  /// get TblCard By TblCardId
  Future<TblCard?> getTblCard(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await TblCard().getById(tblCardId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (Tablehistory)

  static const bool _softDeleteActivated = false;
  TablehistoryManager? __mnTablehistory;

  TablehistoryManager get _mnTablehistory {
    return __mnTablehistory = __mnTablehistory ?? TablehistoryManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (serverId != null || !forView) {
      map['serverId'] = serverId;
    }
    if (serverSync != null) {
      map['serverSync'] = forQuery ? (serverSync! ? 1 : 0) : serverSync;
    } else if (serverSync != null || !forView) {
      map['serverSync'] = null;
    }
    if (replyVoicePath != null || !forView) {
      map['replyVoicePath'] = replyVoicePath;
    }
    if (reply != null || !forView) {
      map['reply'] = reply;
    }
    if (dateQuestion != null) {
      map['dateQuestion'] = forJson
          ? dateQuestion!.toString()
          : forQuery
              ? dateQuestion!.millisecondsSinceEpoch
              : dateQuestion;
    } else if (dateQuestion != null || !forView) {
      map['dateQuestion'] = null;
    }
    if (resultQuestion != null || !forView) {
      map['resultQuestion'] = resultQuestion;
    }
    if (replyTimeInSecond != null || !forView) {
      map['replyTimeInSecond'] = replyTimeInSecond;
    }
    if (goodTimeInSecond != null || !forView) {
      map['goodTimeInSecond'] = goodTimeInSecond;
    }
    if (beforeBoxNumber != null || !forView) {
      map['beforeBoxNumber'] = beforeBoxNumber;
    }
    if (nextBoxNumber != null || !forView) {
      map['nextBoxNumber'] = nextBoxNumber;
    }
    if (tblCardId != null) {
      map['tblCardId'] = forView
          ? plTblCard == null
              ? tblCardId
              : plTblCard!.videoUrl
          : tblCardId;
    } else if (tblCardId != null || !forView) {
      map['tblCardId'] = null;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (serverId != null || !forView) {
      map['serverId'] = serverId;
    }
    if (serverSync != null) {
      map['serverSync'] = forQuery ? (serverSync! ? 1 : 0) : serverSync;
    } else if (serverSync != null || !forView) {
      map['serverSync'] = null;
    }
    if (replyVoicePath != null || !forView) {
      map['replyVoicePath'] = replyVoicePath;
    }
    if (reply != null || !forView) {
      map['reply'] = reply;
    }
    if (dateQuestion != null) {
      map['dateQuestion'] = forJson
          ? dateQuestion!.toString()
          : forQuery
              ? dateQuestion!.millisecondsSinceEpoch
              : dateQuestion;
    } else if (dateQuestion != null || !forView) {
      map['dateQuestion'] = null;
    }
    if (resultQuestion != null || !forView) {
      map['resultQuestion'] = resultQuestion;
    }
    if (replyTimeInSecond != null || !forView) {
      map['replyTimeInSecond'] = replyTimeInSecond;
    }
    if (goodTimeInSecond != null || !forView) {
      map['goodTimeInSecond'] = goodTimeInSecond;
    }
    if (beforeBoxNumber != null || !forView) {
      map['beforeBoxNumber'] = beforeBoxNumber;
    }
    if (nextBoxNumber != null || !forView) {
      map['nextBoxNumber'] = nextBoxNumber;
    }
    if (tblCardId != null) {
      map['tblCardId'] = forView
          ? plTblCard == null
              ? tblCardId
              : plTblCard!.videoUrl
          : tblCardId;
    } else if (tblCardId != null || !forView) {
      map['tblCardId'] = null;
    }

    return map;
  }

  /// This method returns Json String [Tablehistory]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Tablehistory]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      serverId,
      serverSync,
      replyVoicePath,
      reply,
      dateQuestion != null ? dateQuestion!.millisecondsSinceEpoch : null,
      resultQuestion,
      replyTimeInSecond,
      goodTimeInSecond,
      beforeBoxNumber,
      nextBoxNumber,
      tblCardId
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      id,
      serverId,
      serverSync,
      replyVoicePath,
      reply,
      dateQuestion != null ? dateQuestion!.millisecondsSinceEpoch : null,
      resultQuestion,
      replyTimeInSecond,
      goodTimeInSecond,
      beforeBoxNumber,
      nextBoxNumber,
      tblCardId
    ];
  }

  static Future<List<Tablehistory>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Tablehistory.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Tablehistory>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Tablehistory>[];
    try {
      objList = list
          .map((tablehistory) =>
              Tablehistory.fromMap(tablehistory as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Tablehistory.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Tablehistory>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Tablehistory> objList = <Tablehistory>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Tablehistory.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plTblCard'))) {
          obj.plTblCard =
              obj.plTblCard ?? await obj.getTblCard(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Tablehistory by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Tablehistory] if exist, otherwise returns null
  Future<Tablehistory?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    Tablehistory? obj;
    final data = await _mnTablehistory.getById([id]);
    if (data.length != 0) {
      obj = Tablehistory.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plTblCard'))) {
          obj.plTblCard =
              obj.plTblCard ?? await obj.getTblCard(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Tablehistory) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnTablehistory.insert(this, ignoreBatch);
    } else {
      await _mnTablehistory.update(this);
    }

    return id;
  }

  /// Saves the (Tablehistory) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnTablehistory.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnTablehistory.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs Tablehistory. Returns a new Primary Key value of Tablehistory

  /// <returns>Returns a new Primary Key value of Tablehistory
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<Tablehistory> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Tablehistory> tablehistories,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await MyDbModel().batchStart();
    for (final obj in tablehistories) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await MyDbModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < tablehistories.length; i++) {
        if (tablehistories[i].id == null) {
          tablehistories[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnTablehistory.rawInsert(
          'INSERT OR REPLACE INTO tablehistory (id, serverId, serverSync, replyVoicePath, reply, dateQuestion, resultQuestion, replyTimeInSecond, goodTimeInSecond, beforeBoxNumber, nextBoxNumber, tblCardId)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            id,
            serverId,
            serverSync,
            replyVoicePath,
            reply,
            dateQuestion != null ? dateQuestion!.millisecondsSinceEpoch : null,
            resultQuestion,
            replyTimeInSecond,
            goodTimeInSecond,
            beforeBoxNumber,
            nextBoxNumber,
            tblCardId
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Tablehistory id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'Tablehistory id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Tablehistory Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Tablehistory>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<Tablehistory> tablehistories,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnTablehistory.rawInsertAll(
        'INSERT OR REPLACE INTO tablehistory (id, serverId, serverSync, replyVoicePath, reply, dateQuestion, resultQuestion, replyTimeInSecond, goodTimeInSecond, beforeBoxNumber, nextBoxNumber, tblCardId)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?)',
        tablehistories,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes Tablehistory

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Tablehistory invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnTablehistory
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnTablehistory.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [Tablehistory] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  TablehistoryFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return TablehistoryFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  TablehistoryFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return TablehistoryFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    tblCardId = tblCardId ?? 0;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion tablehistory

// region TablehistoryField
class TablehistoryField extends FilterBase {
  TablehistoryField(TablehistoryFilterBuilder tablehistoryFB)
      : super(tablehistoryFB);

  @override
  TablehistoryFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as TablehistoryFilterBuilder;
  }

  @override
  TablehistoryFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as TablehistoryFilterBuilder;
  }

  @override
  TablehistoryFilterBuilder isNull() {
    return super.isNull() as TablehistoryFilterBuilder;
  }

  @override
  TablehistoryFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as TablehistoryFilterBuilder;
  }

  @override
  TablehistoryFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as TablehistoryFilterBuilder;
  }

  @override
  TablehistoryFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as TablehistoryFilterBuilder;
  }

  @override
  TablehistoryFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as TablehistoryFilterBuilder;
  }

  @override
  TablehistoryFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as TablehistoryFilterBuilder;
  }

  @override
  TablehistoryFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as TablehistoryFilterBuilder;
  }

  @override
  TablehistoryFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as TablehistoryFilterBuilder;
  }

  @override
  TablehistoryFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as TablehistoryFilterBuilder;
  }

  @override
  TablehistoryFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as TablehistoryFilterBuilder;
  }

  @override
  TablehistoryField get not {
    return super.not as TablehistoryField;
  }
}
// endregion TablehistoryField

// region TablehistoryFilterBuilder
class TablehistoryFilterBuilder extends ConjunctionBase {
  TablehistoryFilterBuilder(Tablehistory obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnTablehistory = obj._mnTablehistory;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  TablehistoryManager? _mnTablehistory;

  /// put the sql keyword 'AND'
  @override
  TablehistoryFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  TablehistoryFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  TablehistoryFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  TablehistoryFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  TablehistoryFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  TablehistoryFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  TablehistoryFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  TablehistoryFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  TablehistoryFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  TablehistoryFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  TablehistoryFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  TablehistoryField _setField(
      TablehistoryField? field, String colName, DbType dbtype) {
    return TablehistoryField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  TablehistoryField? _id;
  TablehistoryField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  TablehistoryField? _serverId;
  TablehistoryField get serverId {
    return _serverId = _setField(_serverId, 'serverId', DbType.integer);
  }

  TablehistoryField? _serverSync;
  TablehistoryField get serverSync {
    return _serverSync = _setField(_serverSync, 'serverSync', DbType.bool);
  }

  TablehistoryField? _replyVoicePath;
  TablehistoryField get replyVoicePath {
    return _replyVoicePath =
        _setField(_replyVoicePath, 'replyVoicePath', DbType.text);
  }

  TablehistoryField? _reply;
  TablehistoryField get reply {
    return _reply = _setField(_reply, 'reply', DbType.text);
  }

  TablehistoryField? _dateQuestion;
  TablehistoryField get dateQuestion {
    return _dateQuestion =
        _setField(_dateQuestion, 'dateQuestion', DbType.datetime);
  }

  TablehistoryField? _resultQuestion;
  TablehistoryField get resultQuestion {
    return _resultQuestion =
        _setField(_resultQuestion, 'resultQuestion', DbType.integer);
  }

  TablehistoryField? _replyTimeInSecond;
  TablehistoryField get replyTimeInSecond {
    return _replyTimeInSecond =
        _setField(_replyTimeInSecond, 'replyTimeInSecond', DbType.integer);
  }

  TablehistoryField? _goodTimeInSecond;
  TablehistoryField get goodTimeInSecond {
    return _goodTimeInSecond =
        _setField(_goodTimeInSecond, 'goodTimeInSecond', DbType.integer);
  }

  TablehistoryField? _beforeBoxNumber;
  TablehistoryField get beforeBoxNumber {
    return _beforeBoxNumber =
        _setField(_beforeBoxNumber, 'beforeBoxNumber', DbType.integer);
  }

  TablehistoryField? _nextBoxNumber;
  TablehistoryField get nextBoxNumber {
    return _nextBoxNumber =
        _setField(_nextBoxNumber, 'nextBoxNumber', DbType.integer);
  }

  TablehistoryField? _tblCardId;
  TablehistoryField get tblCardId {
    return _tblCardId = _setField(_tblCardId, 'tblCardId', DbType.integer);
  }

  /// Deletes List<Tablehistory> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnTablehistory!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnTablehistory!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from tablehistory ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnTablehistory!.updateBatch(qparams, values);
  }

  /// This method always returns [Tablehistory] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Tablehistory?
  @override
  Future<Tablehistory?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnTablehistory!.toList(qparams);
    final data = await objFuture;
    Tablehistory? obj;
    if (data.isNotEmpty) {
      obj = Tablehistory.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plTblCard'))) {
          obj.plTblCard =
              obj.plTblCard ?? await obj.getTblCard(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Tablehistory]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Tablehistory?
  @override
  Future<Tablehistory> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Tablehistory();
  }

  /// This method returns int. [Tablehistory]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? tablehistoryCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final tablehistoriesFuture = await _mnTablehistory!.toList(qparams);
    final int count = tablehistoriesFuture[0]['CNT'] as int;
    if (tablehistoryCount != null) {
      tablehistoryCount(count);
    }
    return count;
  }

  /// This method returns List<Tablehistory> [Tablehistory]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Tablehistory>
  @override
  Future<List<Tablehistory>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Tablehistory> tablehistoriesData =
        await Tablehistory.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return tablehistoriesData;
  }

  /// This method returns Json String [Tablehistory]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Tablehistory]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Tablehistory]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnTablehistory!.toList(qparams);
  }

  /// Returns List<DropdownMenuItem<Tablehistory>>
  Future<List<DropdownMenuItem<Tablehistory>>> toDropDownMenu(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<Tablehistory>> o)?
          dropDownMenu]) async {
    buildParameters();
    final tablehistoriesFuture = _mnTablehistory!.toList(qparams);

    final data = await tablehistoriesFuture;
    final int count = data.length;
    final List<DropdownMenuItem<Tablehistory>> items = []..add(DropdownMenuItem(
        value: Tablehistory(),
        child: Text('-'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: Tablehistory.fromMap(data[i] as Map<String, dynamic>),
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// Returns List<DropdownMenuItem<int>>
  Future<List<DropdownMenuItem<int>>> toDropDownMenuInt(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<int>> o)?
          dropDownMenu]) async {
    buildParameters();
    qparams.selectColumns = ['id', displayTextColumn];
    final tablehistoriesFuture = _mnTablehistory!.toList(qparams);

    final data = await tablehistoriesFuture;
    final int count = data.length;
    final List<DropdownMenuItem<int>> items = []..add(DropdownMenuItem(
        value: 0,
        child: Text('-'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: data[i]['id'] as int,
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Tablehistory]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `id` FROM tablehistory WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnTablehistory!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Tablehistory]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnTablehistory!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Tablehistory.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnTablehistory!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion TablehistoryFilterBuilder

// region TablehistoryFields
class TablehistoryFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fServerId;
  static TableField get serverId {
    return _fServerId = _fServerId ??
        SqlSyntax.setField(_fServerId, 'serverId', DbType.integer);
  }

  static TableField? _fServerSync;
  static TableField get serverSync {
    return _fServerSync = _fServerSync ??
        SqlSyntax.setField(_fServerSync, 'serverSync', DbType.bool);
  }

  static TableField? _fReplyVoicePath;
  static TableField get replyVoicePath {
    return _fReplyVoicePath = _fReplyVoicePath ??
        SqlSyntax.setField(_fReplyVoicePath, 'replyVoicePath', DbType.text);
  }

  static TableField? _fReply;
  static TableField get reply {
    return _fReply =
        _fReply ?? SqlSyntax.setField(_fReply, 'reply', DbType.text);
  }

  static TableField? _fDateQuestion;
  static TableField get dateQuestion {
    return _fDateQuestion = _fDateQuestion ??
        SqlSyntax.setField(_fDateQuestion, 'dateQuestion', DbType.datetime);
  }

  static TableField? _fResultQuestion;
  static TableField get resultQuestion {
    return _fResultQuestion = _fResultQuestion ??
        SqlSyntax.setField(_fResultQuestion, 'resultQuestion', DbType.integer);
  }

  static TableField? _fReplyTimeInSecond;
  static TableField get replyTimeInSecond {
    return _fReplyTimeInSecond = _fReplyTimeInSecond ??
        SqlSyntax.setField(
            _fReplyTimeInSecond, 'replyTimeInSecond', DbType.integer);
  }

  static TableField? _fGoodTimeInSecond;
  static TableField get goodTimeInSecond {
    return _fGoodTimeInSecond = _fGoodTimeInSecond ??
        SqlSyntax.setField(
            _fGoodTimeInSecond, 'goodTimeInSecond', DbType.integer);
  }

  static TableField? _fBeforeBoxNumber;
  static TableField get beforeBoxNumber {
    return _fBeforeBoxNumber = _fBeforeBoxNumber ??
        SqlSyntax.setField(
            _fBeforeBoxNumber, 'beforeBoxNumber', DbType.integer);
  }

  static TableField? _fNextBoxNumber;
  static TableField get nextBoxNumber {
    return _fNextBoxNumber = _fNextBoxNumber ??
        SqlSyntax.setField(_fNextBoxNumber, 'nextBoxNumber', DbType.integer);
  }

  static TableField? _fTblCardId;
  static TableField get tblCardId {
    return _fTblCardId = _fTblCardId ??
        SqlSyntax.setField(_fTblCardId, 'tblCardId', DbType.integer);
  }
}
// endregion TablehistoryFields

//region TablehistoryManager
class TablehistoryManager extends SqfEntityProvider {
  TablehistoryManager()
      : super(MyDbModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'tablehistory';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion TablehistoryManager
/// Region SEQUENCE IdentitySequence
class IdentitySequence {
  /// Assigns a new value when it is triggered and returns the new value
  /// returns Future<int>
  Future<int> nextVal([VoidCallback Function(int o)? nextval]) async {
    final val = await MyDbModelSequenceManager()
        .sequence(SequenceIdentitySequence.getInstance, true);
    if (nextval != null) {
      nextval(val);
    }
    return val;
  }

  /// Get the current value
  /// returns Future<int>
  Future<int> currentVal([VoidCallback Function(int o)? currentval]) async {
    final val = await MyDbModelSequenceManager()
        .sequence(SequenceIdentitySequence.getInstance, false);
    if (currentval != null) {
      currentval(val);
    }
    return val;
  }

  /// Reset sequence to start value
  /// returns start value
  Future<int> reset([VoidCallback Function(int o)? currentval]) async {
    final val = await MyDbModelSequenceManager()
        .sequence(SequenceIdentitySequence.getInstance, false, reset: true);
    if (currentval != null) {
      currentval(val);
    }
    return val;
  }
}

/// End Region SEQUENCE IdentitySequence

class MyDbModelSequenceManager extends SqfEntityProvider {
  MyDbModelSequenceManager() : super(MyDbModel());
}
// END OF ENTITIES

// BEGIN CONTROLLERS
// BEGIN CONTROLLER (RootGroup)
class RootGroupToSubGroupControllerSub extends SubGroupController {
  static String relationshipFieldName = 'rootGroupId';
  static String primaryKeyName = 'id';
  static bool useSoftDeleting = false;
  //static String formListTitleField = 'videoUrl';
  //static String formListSubTitleField = 'title';
}

class RootGroupController extends RootGroup {
  String formListTitleField = 'videoUrl';
  String formListSubTitleField = 'title';
  static SQFViewList getController = SQFViewList(
    RootGroupController(),
    primaryKeyName: 'id',
    useSoftDeleting: true,
  );
  Map<String, String> subMenu() {
    final menu = <String, String>{};
    menu['RootGroupToSubGroup'] = 'RootGroup To SubGroup(rootGroupId)';

    return menu;
  }

  SQFViewList? subList(int id, String controllerName) {
    switch (controllerName) {
      case 'RootGroupToSubGroup':
        return SQFViewList(
          RootGroupToSubGroupControllerSub(),
          primaryKeyName: RootGroupToSubGroupControllerSub.primaryKeyName,
          useSoftDeleting: RootGroupToSubGroupControllerSub.useSoftDeleting,
          //formListTitleField: 'videoUrl',
          //formListSubTitleField: 'title',
          filterExpression:
              '${RootGroupToSubGroupControllerSub.relationshipFieldName}=?',
          filterParameter: id,
        );

      default:
        return null;
    }
  }

  Future<Widget> gotoEdit(dynamic obj) async {
    return RootGroupAdd(obj == null
        ? RootGroup()
        : await RootGroup().getById(obj['id'] as int) ?? RootGroup());
  }
}
// END CONTROLLER (RootGroup)

// BEGIN CONTROLLER (SubGroup)
class SubGroupToLessonControllerSub extends LessonController {
  static String relationshipFieldName = 'subGroupId';
  static String primaryKeyName = 'id';
  static bool useSoftDeleting = false;
  //static String formListTitleField = 'videoUrl';
  //static String formListSubTitleField = 'title';
}

class SubGroupController extends SubGroup {
  String formListTitleField = 'videoUrl';
  String formListSubTitleField = 'title';
  static SQFViewList getController = SQFViewList(
    SubGroupController(),
    primaryKeyName: 'id',
    useSoftDeleting: false,
  );
  Map<String, String> subMenu() {
    final menu = <String, String>{};
    menu['SubGroupToLesson'] = 'SubGroup To Lesson(subGroupId)';

    return menu;
  }

  SQFViewList? subList(int id, String controllerName) {
    switch (controllerName) {
      case 'SubGroupToLesson':
        return SQFViewList(
          SubGroupToLessonControllerSub(),
          primaryKeyName: SubGroupToLessonControllerSub.primaryKeyName,
          useSoftDeleting: SubGroupToLessonControllerSub.useSoftDeleting,
          //formListTitleField: 'videoUrl',
          //formListSubTitleField: 'title',
          filterExpression:
              '${SubGroupToLessonControllerSub.relationshipFieldName}=?',
          filterParameter: id,
        );

      default:
        return null;
    }
  }

  Future<Widget> gotoEdit(dynamic obj) async {
    return SubGroupAdd(obj == null
        ? SubGroup()
        : await SubGroup().getById(obj['id'] as int) ?? SubGroup());
  }
}
// END CONTROLLER (SubGroup)

// BEGIN CONTROLLER (Lesson)
class LessonToTblCardControllerSub extends TblCardController {
  static String relationshipFieldName = 'lessonId';
  static String primaryKeyName = 'id';
  static bool useSoftDeleting = false;
  //static String formListTitleField = 'title';
  //static String formListSubTitleField = 'videoUrl';
}

class LessonController extends Lesson {
  String formListTitleField = 'title';
  String formListSubTitleField = 'videoUrl';
  static SQFViewList getController = SQFViewList(
    LessonController(),
    primaryKeyName: 'id',
    useSoftDeleting: false,
  );
  Map<String, String> subMenu() {
    final menu = <String, String>{};
    menu['LessonToTblCard'] = 'Lesson To TblCard(lessonId)';

    return menu;
  }

  SQFViewList? subList(int id, String controllerName) {
    switch (controllerName) {
      case 'LessonToTblCard':
        return SQFViewList(
          LessonToTblCardControllerSub(),
          primaryKeyName: LessonToTblCardControllerSub.primaryKeyName,
          useSoftDeleting: LessonToTblCardControllerSub.useSoftDeleting,
          //formListTitleField: 'title',
          //formListSubTitleField: 'videoUrl',
          filterExpression:
              '${LessonToTblCardControllerSub.relationshipFieldName}=?',
          filterParameter: id,
        );

      default:
        return null;
    }
  }

  Future<Widget> gotoEdit(dynamic obj) async {
    return LessonAdd(obj == null
        ? Lesson()
        : await Lesson().getById(obj['id'] as int) ?? Lesson());
  }
}
// END CONTROLLER (Lesson)

// BEGIN CONTROLLER (TblCard)
class TblCardToTablehistoryControllerSub extends TablehistoryController {
  static String relationshipFieldName = 'tblCardId';
  static String primaryKeyName = 'id';
  static bool useSoftDeleting = false;
  //static String formListTitleField = 'videoUrl';
  //static String formListSubTitleField = 'question';
}

class TblCardController extends TblCard {
  String formListTitleField = 'videoUrl';
  String formListSubTitleField = 'question';
  static SQFViewList getController = SQFViewList(
    TblCardController(),
    primaryKeyName: 'id',
    useSoftDeleting: false,
  );
  Map<String, String> subMenu() {
    final menu = <String, String>{};
    menu['TblCardToTablehistory'] = 'TblCard To Tablehistory(tblCardId)';

    return menu;
  }

  SQFViewList? subList(int id, String controllerName) {
    switch (controllerName) {
      case 'TblCardToTablehistory':
        return SQFViewList(
          TblCardToTablehistoryControllerSub(),
          primaryKeyName: TblCardToTablehistoryControllerSub.primaryKeyName,
          useSoftDeleting: TblCardToTablehistoryControllerSub.useSoftDeleting,
          //formListTitleField: 'videoUrl',
          //formListSubTitleField: 'question',
          filterExpression:
              '${TblCardToTablehistoryControllerSub.relationshipFieldName}=?',
          filterParameter: id,
        );

      default:
        return null;
    }
  }

  Future<Widget> gotoEdit(dynamic obj) async {
    return TblCardAdd(obj == null
        ? TblCard()
        : await TblCard().getById(obj['id'] as int) ?? TblCard());
  }
}
// END CONTROLLER (TblCard)

// BEGIN CONTROLLER (Tablehistory)

class TablehistoryController extends Tablehistory {
  String formListTitleField = 'replyVoicePath';
  String formListSubTitleField = 'reply';
  static SQFViewList getController = SQFViewList(
    TablehistoryController(),
    primaryKeyName: 'id',
    useSoftDeleting: false,
  );
  Map<String, String> subMenu() {
    final menu = <String, String>{};

    return menu;
  }

  Future<Widget> gotoEdit(dynamic obj) async {
    return TablehistoryAdd(obj == null
        ? Tablehistory()
        : await Tablehistory().getById(obj['id'] as int) ?? Tablehistory());
  }
}
// END CONTROLLER (Tablehistory)

// END OF CONTROLLERS
